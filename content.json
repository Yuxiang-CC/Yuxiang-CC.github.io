{"meta":{"title":"雨巷的伞","subtitle":"","description":"Java 微服务 cloud vue 雨巷","author":"yuxiang","url":"http://yuxiangai.cn","root":"/"},"pages":[{"title":"所有分类","date":"un33fin33","updated":"un33fin33","comments":false,"path":"categories/index.html","permalink":"http://yuxiangai.cn/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"un44fin44","updated":"un44fin44","comments":true,"path":"404.html","permalink":"http://yuxiangai.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"un11fin11","updated":"un11fin11","comments":false,"path":"friends/index.html","permalink":"http://yuxiangai.cn/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"un33fin33","updated":"un33fin33","comments":false,"path":"about/index.html","permalink":"http://yuxiangai.cn/about/index.html","excerpt":"","text":"关于我 雨巷的伞 大三 00后 程序员"},{"title":"所有标签","date":"un33fin33","updated":"un33fin33","comments":false,"path":"tags/index.html","permalink":"http://yuxiangai.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git简介与命令使用","slug":"Git简介与命令使用","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/11/02/Git简介与命令使用/","link":"","permalink":"http://yuxiangai.cn/2020/11/02/Git%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/","excerpt":"Git入门和常用命令操作","text":"Git入门和常用命令操作 git命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 比较文件不同git diff HEAD# 工作区与本地仓库比较不同git diff --cached# 工作区与缓存区比较不同# 从缓存区中删除文件 但 不删除工作区中文件git reset HEAD -- [文件名]git rm --cached [文件名]# 从缓存区中删除文件 并且 删除工作区中的文件git rm [文件名]# 将缓存区中的文件重命名并重新添加到缓存区git mv [原文件名] [更改后文件名]# 创建分支git branch [分支名] # // 如果分支名不写则列出所有分支# 切换分支git checkout [分支名]# 删除分支git checkout -d [分支名]# 将指定分支 与 当前分支合并，当出现冲突时需要自己解决冲突后，commit来完成 merge操作git merge [分支名] # 查看历史版本git log git log --oneline # 仅仅一行显示git log --graph # 查看历史中什么时候出现了分支、合并。git log --reverse # 逆向查看历史中什么时候出现分支、合并。git log --author=[作者]git 标签git tag # 查看所有标签# git tag 默认为当前HEAD指向的版本添加标签 ，可以添加之前版本的hansh值来为之前的版本添加hash值git tag -a [标签名] -m [&#x27;描述信息&#x27;] [之前版本的hash值]# 添加远程库git remote add [远程仓库别名] [url]# 查看当前远程库git remotegit remote -v# 提取远程仓库git fetch # 该命令执行完后需要执行git merge 远程分支到你所在的分支。git pull # 从远端仓库提取数据并尝试合并到当前分支# 推送到远程仓库git push [远程仓库别名] [branch]# 删除远程仓库git remote rm [别名] github搜索 按名字搜索 in:name [spring boot] 按star搜索 in:name [spring boot/spring] stars:&gt;数量(300) 按fork数搜索 in:name [spring boot/spring] stars:&gt;数量(300) forks:&gt;数量 按readme搜索 in:readme [spring boot] [stars:&gt;数量(300)] [forks:&gt;数量] 按描述搜索 in:description [spring cloud] [language:java] [上传时间 pushd:&gt;日期] in:description [爬虫] language:python stars:&gt;200 明确搜索某个人或组织的仓库 user:userName user:userName language:java org:spring-cloud","categories":[{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/tags/git/"}]},{"title":"PolarDB和ECS搭建门户网站","slug":"PolarDB和ECS搭建门户网站","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/11/02/PolarDB和ECS搭建门户网站/","link":"","permalink":"http://yuxiangai.cn/2020/11/02/PolarDB%E5%92%8CECS%E6%90%AD%E5%BB%BA%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99/","excerpt":"使用PolarDB和ECS搭建门户网站","text":"使用PolarDB和ECS搭建门户网站 PolarDB简介PolarDB是阿里云自研的下一代关系型云数据库，有三个独立的引擎，分别可以100%兼容MySQL、100%兼容PostgreSQL、高度兼容Oracle语法，存储容量最高可达100TB，单库最多可扩展到16个节点，适用于企业多样化的数据库应用场景。 PolarDB采用存储和计算分离的架构，所有计算节点共享一份数据，提供分钟级的配置升降级、秒级的故障恢复、全局数据一致性和免费的数据备份容灾服务。PolarDB既融合了商业数据库稳定可靠、高性能、可扩展的特征，又具有开源云数据库简单开放、自我迭代的优势，例如PolarDB MySQL性能最高可以提升至MySQL的6倍，而成本只有商用数据库的1/10。集群架构，计算与存储分离。 开通、连接资源PolarDB免费上手体验。 单击免费开通创建所需资源。 连接服务器。使用CMD、Powershell、Xshell等工具都可以。 创建PolarDB数据库账号 单击页面左侧云产品资源下的一键复制登录url 。 在浏览器中打开，使用RAM用户 登录。 在 阿里云控制台首页 左侧导航栏，依次单击 产品与服务 &gt; 云数据库PolarDB ，进入 云数据库PolarDB管理控制台 。 单击左侧 集群列表 ，然后选择云产品资源提供的地域。 创建数据库账号。 1）、 在 集群列表 页面，单击 集群ID ，进入 集群详情界面 。 2）、单击左侧导航栏 配置与管理 &gt; 账号管理 。 3）、单击左上方 创建账号 。 4）、设置账号密码，然后单击 确定 。 创建数据库。 1）、在实例详情页，单击左侧导航栏的 数据库管理 ，然后单击 创建数据库 。 2）、参考说明配置数据库信息，然后单击 创建 。 配置访问白名单。 安装环境安装Apache、MySQL和PHP的环境。 安装Apache服务及其扩展包。 1yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql 安装PHP环境。 1yum -y install php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap 下载并安装MySQL。 123wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-server 启动MySQL数据库。 12systemctl start mysqldsystemctl status mysqld 搭建门户网站 安装git。 1yum install git -y 下载PbootCMS源码文件。 PbootCMS是全新内核且永久开源免费的PHP企业网站开发建设管理系统，是一套高效、简洁、 强悍的可免费商用的PHP CMS源码，能够满足各类企业网站开发建设的需要。系统采用简单到想哭的模板标签，只要懂HTML就可快速开发企业网站。 1cd ~ &amp;&amp; git clone https://gitee.com/hnaoyun/PbootCMS.git 将安装包拷贝到Apache的wwwroot目录下。 1cp -r PbootCMS/* /var/www/html/ 修改站点根目录文件权限。 1chmod -R a+w /var/www/html 向数据库中导入CMS的初始数据。 1）、获取sql文件。 1sql_file=&quot;/var/www/html/static/backup/sql/&quot;$(ls /var/www/html/static/backup/sql/) &amp;&amp; echo $sql_file 2）、连接数据库，并导入CMS的初始数据。 数据库连接地址：在开通资源左侧处 1234mysql -h&lt;数据库连接地址&gt; -u&lt;用户名&gt; -p&lt;密码&gt;sql_file=&quot;/var/www/html/static/backup/sql/&quot;$(ls /var/www/html/static/backup/sql/) &amp;&amp;mysql -hpc-uf606ov9nvsq2sh62.mysql.polardb.rds.aliyuncs.com -uyuxiang_test -pYuxiang123 -Dpbootcms &lt; $sql_file 3）、修改CMS系统数据库配置。 12345678910111213cat &gt; /var/www/html/config/database.php &lt;&lt; EOF&lt;?phpreturn array( &#x27;database&#x27; =&gt; array( &#x27;type&#x27; =&gt; &#x27;mysqli&#x27;, // 数据库连接驱动类型: mysqli,sqlite,pdo_mysql,pdo_sqlite &#x27;host&#x27; =&gt; &#x27;数据库连接地址&#x27;, // PolarDB数据库链接地址 &#x27;user&#x27; =&gt; &#x27;yuxiang_user&#x27;, // PolarDB数据库的用户名 &#x27;passwd&#x27; =&gt; &#x27;Yuxiang123&#x27;, // PolarDB数据库的密码 &#x27;port&#x27; =&gt; &#x27;3306&#x27;, // 数据库端口 &#x27;dbname&#x27; =&gt; &#x27;pbootcms&#x27; //数据库名称 ));EOF 在ECS实例列表页面，单击已创建的ECS实例ID链接进入ECS详情页，左侧导航栏，单击 本实例安全组 ，然后单击安全组的ID链接查看安全组配置。 访问程序。 重启 Apache服务。 1systemctl restart httpd 在浏览器地址栏输入云服务器的公网IP地址，进入门户网站首页。 系统后台默认访问路径为http://&lt;ECS公网IP地址&gt;/admin.php。默认账号为admin，密码为123456。 至此您已完成门户网站的搭建，您可以根据公司的需求自定义门户网站的内容。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB搭建网站","slug":"阿里云/PolarDB搭建网站","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/PolarDB%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB","slug":"PolarDB","permalink":"http://yuxiangai.cn/tags/PolarDB/"}]},{"title":"阿里云SLB负载均衡实践","slug":"SLB负载均衡实践","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2020/11/01/SLB负载均衡实践/","link":"","permalink":"http://yuxiangai.cn/2020/11/01/SLB%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E8%B7%B5/","excerpt":"基于阿里云ECS和SLB实现负载均衡","text":"基于阿里云ECS和SLB实现负载均衡 SLB简介负载均衡（Server Load Balancer）是将访问流量根据转发策略分发到后端多台云服务器（ECS实例）的流量分发控制服务。负载均衡扩展了应用的服务能力，增强了应用的可用性。 负载均衡通过设置虚拟服务地址，将添加的ECS实例虚拟成一个高性能、高可用的应用服务池，并根据转发规则，将来自客户端的请求分发给云服务器池中的ECS实例。 负载均衡默认检查云服务器池中ECS实例的健康状态，自动隔离异常状态的ECS实例，消除了单台ECS实例的单点故障，提高了应用的整体服务能力。此外，负载均衡还具备抗DDoS攻击的能力，增强了应用服务的防护能力。 架构负载均衡服务主要有三个核心概念： 负载均衡实例 （Server Load Balancer instances） 一个负载均衡实例是一个运行的负载均衡服务，用来接收流量并将其分配给后端服务器。要使用负载均衡服务，您必须创建一个负载均衡实例，并至少添加一个监听和两台ECS实例。 监听 （Listeners） 监听用来检查客户端请求并将请求转发给后端服务器。监听也会对后端服务器进行健康检查。 后端服务器（Backend Servers） 一组接收前端请求的ECS实例。您可以单独添加ECS实例到服务器池，也可以通过虚拟服务器组或主备服务器组来批量添加和管理。 开通资源阿里云SLB负载均衡，免费开通体验。 左侧显示相关资源信息。 查看云服务器状态打开浏览器，访问两台ECS服务器地址，查看状态。 负载均衡配置 点击左侧导航栏处的 云产品资源 查看资源信息，点击 一键复制url，用浏览器登录控制台。 输入实验提供的 子用户名称 和 子用户密码 ，完成后点击 登录 。登录阿里云管理控制台。 在产品与服务中搜索负载均衡，选择弹性计算下的负载均衡。 选择华东2（上海），选择实例 -》实例管理，点击点我开始配置。 通过负载均衡业务配置向导，配置负载均衡的 监听端口、后端服务器 和 健康检查 1）、在 后端服务器 页面，监听请求转发至 默认服务器组，在已添加服务器处点击 继续添加 。 2）、在弹出的待添加服务器页面，在预先配置好的两台云服务器前打勾选择，然后点击下一步，之后再点击 添加； 3）、设置端口号为80，下一步。 刷新负载均衡实例查看状态。 访问测试权重相同此时，两台后端服务器的权重比例相同。 在控制台点击左侧 实例管理 ，在右侧页面中的红框处看到负载均衡的 服务地址（也就是 云产品资源 提供的 负载均衡 的 IP地址）。 在浏览器中新建页面，并访问 负载均衡 的 服务地址 。界面显示的 后端服务器IP 为 云服务器ECS-1（或 云服务器ECS-2） 的 内网地址 。 刷新 浏览页面，显示的 后端服务器IP 将发生变化，变为 云服务器ECS-2（或 云服务器ECS-1）的 内网地址 ； 说明：界面显示的地址为内网地址，这是因为负载均衡访问后端ECS实例，是通过内网访问的。 重复刷新操作，观察 后端服务器IP 是在两个云服务器的 内网地址 间轮流更换，可以减轻单台服务器的负载压力，从而确保业务的持续性。 权重不同修改后端服务器权重，验证负载均衡向后端服务器发送请求的比例是按照权重的比例调整的。 进入实例管理 页面，点击该实例的 默认服务器组 ； 选中 已添加的服务器 ，列表中，勾选下方的勾选框 ，然后点击 修改权重 ； 返回已添加的服务器的页面，查看到两台 ECS实例 的权重分别为 30 和 90 ，并记录对应的 ECS实例 内网地址。 浏览器中，刷新多次负载均衡 服务地址 的页面，并记录页面显示的 后端服务器IP 。可以发现：每 4 次刷新，将有 3 次访问 权重 为 90 的 ECS实例，1 次访问权重为 30 的 ECS实例。 结果：证明用户可以根据实际情况调整负载均衡器的请求分发，一般将配置高的服务器设置的权重调高，配置较低的服务器设置的权重调低。这样可以避免在高并发时，配置较低的服务器因为压力较大服务异常的发生。 模拟宕机首先开启负载均衡的 会话保持 功能。 1）点击左侧 监听 ，监听页面点击右侧的 修改监听配置 。 2） 配置监听页面的 高级配置 处，点击 修改 ； 3）开启 会话保持 ，超时时间 输入 180 （即 3 分钟）；完成后点击 下一步 4）下面的 后端服务器、健康检查 和 配置审核 页面都采用默认值 ，依次完成配置。 返回到 监听 页面 ，会话保持 状态 已开启 。 再次在浏览器中输入 负载均衡 的 IP地址 ，多次刷新，发现在会话保持的超时时间内请求只会分发到某一台 ECS 上（究竟是哪一台 ECS 没有规定），时间超出后，重新按照权重比例分发。 我们关掉刚才访问的那台机器。 返回负载均衡管理控制台，在默认服务器组页面中点击右上角的【刷新】，页面刷新后被停止的 ECS 的 状态 变为 已停止。监听 页面，也出现 异常 提示 。 点击左上角的 【实例管理 】，返回负载均衡管理控制台主页面，异常 报警也会出现。 再次刷新浏览器中 负载均衡 的 IP地址 ，此时，请求发送到 健康检查状态 为 正常 的ECS上。 结果：当某一台 ECS 出现异常后，负载均衡会自动将请求发送到健康检查状态正常的 ECS 上。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"SBL负载均衡","slug":"阿里云/SBL负载均衡","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/SBL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"SLB","slug":"SLB","permalink":"http://yuxiangai.cn/tags/SLB/"}]},{"title":"阿里云ECS搭建Docker环境","slug":"ECS搭建Docker环境","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2020/10/31/ECS搭建Docker环境/","link":"","permalink":"http://yuxiangai.cn/2020/10/31/ECS%E6%90%AD%E5%BB%BADocker%E7%8E%AF%E5%A2%83/","excerpt":"基于阿里云ECS搭建Docker环境、服务简单部署","text":"基于阿里云ECS搭建Docker环境、服务简单部署 简介Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。 Docker名词解释： 镜像：Docker 镜像是容器应用打包的标准格式，是创建容器的模板。 容器：一个通过 Docker 镜像创建的运行时实例，一台主机可运行多个同一镜像的容器实例。 安装、启动 首先开通阿里云ECS资源，免费体验，还在等什么呢。 连接。 用 CMD Powershell Terminal均可, 我在此使用CMD 命令：ssh [username]@[ipaddress] 安装Docker CE。 1234567891011# 1. 安装Docker依赖库yum install -y yum-utils device-mapper-persistent-data lvm2# 2. 安装Docker CE的软件源信息yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 3. 安装Docker CEyum makecache fastyum -y install docker-ce# 4. 启动Docker服务systemctl start docker# 查看Docker启动情况systemctl status docker 配置镜像加速Docker的默认官方远程仓库是hub.docker.com，由于网络原因，下载一个Docker官方镜像可能会需要很长的时间，甚至下载失败。为此，阿里云容器镜像服务ACR提供了官方的镜像站点，从而加速官方镜像的下载。下面介绍如何使用阿里云镜像仓库。 使用子账户登录阿里云。 在页面左侧资源栏点击 一键复制登录url，在浏览器中打开。进行RAM用户登录。 在左侧产品与服务中搜索镜像。 单击容器镜像服务，若提示未开通服务，关闭即可。 单击【镜像中心】 &gt; 【镜像加速器】，可以看到阿里云为您提供了一个专属的镜像加速地址。 配置Docker仓库地址为在 【镜像加速器】中的加速器地址。 1234567891011[root@i1kzth4Z ~]# ls /etc/docker/key.json[root@i1kzth4Z ~]# cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&gt; &#123;&gt; &quot;registry-mirrors&quot;: [&quot;https://xxxx.aliyuncs.com&quot;]&gt; &#125;&gt; EOF[root@i1kzth4Z ~]# cat /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://xxxx.aliyuncs.com&quot;]&#125; 重新加载配置文件，重启服务。 1234# 加载配置文件systemctl daemon-reload# 重启服务systemctl restart docker Docker常用命令docker search 根据名字搜索镜像 用法：docker search [OPTIONS] TERM 12345678[root@iicxcxq7nz ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 13942 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1902 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 791 [OK]linuxserver/nginx An Nginx container, brought to you by LinuxS… 128 jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 106 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 101 [OK] docker pull 从远程仓库拉去镜像 用法：docker pull [OPTIONS] NAME[:TAG|@DIGEST] 12345678910[root@iicxcxq7nz ~]# docker pull nginx:latestlatest: Pulling from library/nginxbb79b6b2107f: Already exists 111447d5894d: Pull complete a95689b8e6cb: Pull complete 1a0022e444c2: Pull complete 32b7488a3833: Pull complete Digest: sha256:ed7f815851b5299f616220a63edac69a4cc200e7f536a56e421988da82e44ed8Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest docker images 查看本地镜像列表 用法：docker images [OPTIONS] [REPOSITORY[:TAG]] 123456789[root@iicxcxq7nz ~]# docker images nginx:latestREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f35646e83998 2 weeks ago 133MB[root@iicxcxq7nz ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f35646e83998 2 weeks ago 133MBmysql 5.7 42cdba9f1b08 2 weeks ago 448MBnginx 1.12 4037a5562b03 2 years ago 108MB docker run 通过镜像开始一个运行实例 用法：docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 1234567[root@iicxcxq7nz ~]# docker run --name mysql \\-p 3306:3306 \\-v /home/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /home/mysql/logs:/logs \\-v /home/mysql/data/mysql:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:5.6 \\ --name：设置容器实例名称 -p：宿主机与容器端口绑定 -v：挂载目录或数据卷，将容器内的文件夹与宿主机文件夹映射，方便修改容器内的文件。 -e：设置容器内MySQL服务Root用户密码 -d：后台守护运行，返回容器实例ID docker ps 查看容器 用法：docker ps [OPTIONS] 参数: -a：显示全部 -n &lt;num&gt;：显示最新运行的个容器 -l：显示最新创建的容器(包括所有状态) -q：仅显示容器ID -s：显示容器总大小 123456[root@iicxcxq7nz demo]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES33a5981c417d nginx:latest &quot;/docker-entrypoint.…&quot; 8 minutes ago Up 8 minutes 0.0.0.0:8080-&gt;80/tcp nginx-test[root@iicxcxq7nz demo]# docker ps -sCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE33a5981c417d nginx:latest &quot;/docker-entrypoint.…&quot; 8 minutes ago Up 8 minutes 0.0.0.0:8080-&gt;80/tcp nginx-test 1.29kB (virtual 133MB) 搭建Nginx服务 拉取最新Nginx镜像。 1docker pull nginx:latest 运行容器。 1docker run --name nginx-test -p 8080:80 -d nginx:latest 运行结果如下 在浏览器地址栏输入http://&lt;公网地址&gt;:8080访问Nginx服务。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Docker","slug":"阿里云/Docker","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/Docker/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Docker","slug":"Docker","permalink":"http://yuxiangai.cn/tags/Docker/"}]},{"title":"阿里云ECS搭建FTP服务","slug":"ECS搭建FTP服务","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2020/10/30/ECS搭建FTP服务/","link":"","permalink":"http://yuxiangai.cn/2020/10/30/ECS%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1/","excerpt":"基于ECS，使用vsftpd搭建FTP服务","text":"基于ECS，使用vsftpd搭建FTP服务 环境 CentOS Linux release 7.3.1611 vsftpd-3.0.2-27.el7.x86_64 前置知识 chmod命令 Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 语法&amp;例子 123456789chmod [-cfvR] [--help] [--version] mode file...# u：用户 g：组 o：其他 a：全部# 将文件 file1.txt 设为所有人皆可读取chmod ugo+r file1.txt # 或 chmod a+r file1.txt# 也可以用数字代替 4=r，2=w，1=x # 将目前目录下的所有文件与子目录皆设为任何人可读取chmod 777 * # 或 chmod a+rwx * chown命令 Linux chown（英文全拼：change owner）命令用于设置文件所有者和文件关联组的命令。 Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 chown 需要超级用户 root 的权限才能执行此命令。 语法&amp;例子 1234567chown [-cfhvR] [--help] [--version] user[:group] file...# 将文件 file1.txt 的拥有者设为 yuxiang，群体的使用者 yuxianggroupchown yuxiang:yuxianggroup file1.txt# 将当前前目录下的所有文件与子目录的拥有者皆设为 yuxiang，群体的使用者 yuxianggroupchown -R yuxiang:yuxianggroup *# -R : 处理指定目录以及其子目录下的所有文件 sed命令 Linux sed 命令是利用脚本来处理文本文件。 sed 可依照脚本的指令来处理、编辑文本文件。 Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 ftp客户端命令 123456789101112131415161718192021222324252627282930#进入ftp客户端ftp#打开ftp服务器&gt;open xxx.xxx.xxx.xxx#查看远程目录&gt;dir#查看本地目录&gt;!dir #指定本地目录&gt;lcd#切换远程目录&gt;cd 目录#上传文件&gt;put 文件名#上传文件,支持*通配&gt;mput 文件名#下载文件&gt;get 文件名#下载文件,支持*通配&gt;mget 文件名#删除远程文件&gt;delete 文件名#退出服务器&gt;bye 开通、连接资源阿里云ECS搭建FTP服务开通资源，免费体验。 连接 ：使用CMD、Powershell、Xshell等工具都可以。 安装、启动vsftpd1234567# 1. 安装yum install -y vsftpd# 2. 运行systemctl start vsftpd.service# 3. 查看运行结果systemctl status vsftpd.servicenetstat -tunap | grep ftp 配置vsftpdvsftpd（very secure FTP daemon）是一款在Linux发行版中最受推崇的FTP服务器。vsftpd支持匿名访问和本地用户模式两种访问方式。匿名访问方式任何用户都可以访问搭建的FTP服务；本地用户模式只支持添加的本地用户访问搭建的FTP服务。 说明: 匿名用户模式和本地用户模式只可同时配置一种。 匿名用户模式 修改配置文件vsftpd.conf。 1vim /etc/vsftpd/vsftpd.conf 将匿名长传权限anon_upload_enable=YES的注释解开。 退出编辑模式，输入:wq保存并退出vim编辑器。 为FTP用户添加写权限。 1chmod o+w /var/ftp/pub/ 重启服务。 1systemctl restart vsftpd.service 访问测试。 在/var/ftp/pub目录下创建hello.js文件 12345678[root@ic5x28dikeZ ~]# cd /var/ftp/pub/[root@ic5x28dikeZ pub]# touch hello.js[root@ic5x28dikeZ pub]# cat &gt;&gt; ./hello.js &lt;&lt; EOF&gt; console.log(&#x27;hello world vsftpd&#x27;);&gt; EOF[root@c5x28dikeZ pub]# cat hello.jsconsole.log(&#x27;hello world vsftpd&#x27;);[root@ic5x28dikeZ pub]# 本地用户模式 为FTP服务创建一个Liunx用户。 1234# 创建用户adduser ftptest# 设置密码passwd ftptest 创建一个供FTP服务使用的文件目录。 1mkdir /var/ftp/test 更改/var/ftp/test目录的拥有者为ftptest. 1chowm -R ftptest:ftptest /var/ftp/test 修改/etc/vsftpd/vsftpd.conf配置文件。 FTP两种模式：主动模式、被动模式。详细可自行搜索。 主动模式配置 12345678sed -i &#x27;s/anonymous_enable=YES/anonymous_enable=NO/&#x27; /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 sed -i &#x27;s/listen=NO/listen=YES/&#x27; /etc/vsftpd/vsftpd.conf #监听IPv4 sockets sed -i &#x27;s/listen_ipv6=YES/#listen_ipv6=YES/&#x27; /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets sed -i &#x27;s/#chroot_local_user=YES/chroot_local_user=YES/&#x27; /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 sed -i &#x27;s/#chroot_list_enable=YES/chroot_list_enable=YES/&#x27; /etc/vsftpd/vsftpd.conf #启用例外用户名单 sed -i &#x27;s/#chroot_list_file=/chroot_list_file=/&#x27; /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 echo &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf echo &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 被动模式配置 12345678910111213sed -i &#x27;s/anonymous_enable=YES/anonymous_enable=NO/&#x27; /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 sed -i &#x27;s/listen=NO/listen=YES/&#x27; /etc/vsftpd/vsftpd.conf #监听IPv4 sockets sed -i &#x27;s/listen_ipv6=YES/#listen_ipv6=YES/&#x27; /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets sed -i &#x27;s/#chroot_local_user=YES/chroot_local_user=YES/&#x27; /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 sed -i &#x27;s/#chroot_list_enable=YES/chroot_list_enable=YES/&#x27; /etc/vsftpd/vsftpd.conf #启用例外用户名单 sed -i &#x27;s/#chroot_list_file=/chroot_list_file=/&#x27; /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 echo &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf echo &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 echo &quot;pasv_enable=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #开启被动模式 echo &quot;pasv_address=&lt;FTP服务器公网IP地址&gt;&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #本教程中为ECS服务器弹性IP echo &quot;pasv_min_port=20&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最小值 echo &quot;pasv_max_port=21&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最大值 在/etc/vsftpd目录下创建chroot_list文件，并在在文件中写入例外用户名单。 12345#使用vim命令编辑chroot_list文件，添加例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。vim /etc/vsftpd/chroot_list# 添加用户ftptest# 保存退出 说明：没有例外用户时，也必须创建chroot_list文件，内容可为空。 重启服务。 1systemctl restart vsftpd.service 测试。 浏览器访问测试。 1234567891011121314[root@iicxcxq7nz test]# touch TestMain.java[root@iicxcxq7nz test]# cat &gt;&gt; ./TestMain.java &lt;&lt; EOF&gt; public class TestMain &#123;&gt; public static void main(String agrs[]) &#123;&gt; System.out.println(&#x27;hello vsftpd user&#x27;);&gt; &#125;&gt; &#125;&gt; EOF[root@iicxcxq7nz test]# tree /var/ftp/test/test/└── yuxiang └── TestMain.java1 directory, 1 file ftp工具上传测试。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"ftp服务","slug":"阿里云/ftp服务","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/ftp%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://yuxiangai.cn/tags/vsftpd/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"MySQL索引和事务介绍","slug":"MySQL索引和事务介绍","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2020/10/21/MySQL索引和事务介绍/","link":"","permalink":"http://yuxiangai.cn/2020/10/21/MySQL%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/","excerpt":"MySQL索引介绍和事务演示","text":"MySQL索引介绍和事务演示 环境版本：mysql 8.0.17 索引索引介绍 索引是帮助MySQL高效获取数据的数据结构 索引存储在文件系统中 索引的文件形式与存储引擎有关 索引文件的结构 hash 二叉树 B树 B+树 索引的优点 大大减少了服务器需要扫描的数据量 帮助服务器避免排序和临时表 将随机io变成顺序io 索引的用处 快速查找WHERE子句匹配的行 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行 当有表连接的时候，从替他表检索行数据 查找特定索引列的min或max值 如果排序分组时可在索引的最左前缀上完成的，则对表进行排序和分组 在某些情况下，可以优化查询以检索值而无需查询数据行 从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用到最少行的索引 索引的分类 主键索引 唯一索引 普通索引 全文索引 组合索引 技术名词回表 InnoDB的索引实现，InnoDB有两大类索引： 聚集索引 非聚集索引 InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引： （1）如果表定义了Primary Key，则Primary Key就是聚集索引； （2）如果表没有定义Primary Key，则第一个not NULL unique列是聚集索引； （3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引； 当为name字段也建立索引，并按照name字段查询行内全部数据时会触发回表。 1explain select * from u_user where name &#x3D; &#39;li&#39;\\G 覆盖索引 当查找的数据只通过一个索引树就可以得到结果，无需回表。 1explain select id, name from u_user where name &#x3D; &#39;li&#39;\\G 最左匹配 以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。 索引下推 MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 索引的匹配方式1234567891011# 员工表create table staffs ( id int PRIMARY key auto_increment, name VARCHAR(24) not null COMMENT &#39;姓名&#39;, age int not null COMMENT &#39;年龄&#39;, pos VARCHAR(20) not null COMMENT &#39;职位&#39;, add_time TIMESTAMP not null COMMENT &#39;入职时间&#39;) CHARSET utf8 comment &#39;员工记录表&#39;;# 添加组合索引alter table staffs add index idx_nap(name,age,pos); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 查看索引mysql&gt; show index from staffs\\G*************************** 1. row *************************** Table: staffs Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL*************************** 2. row *************************** Table: staffs Non_unique: 1 Key_name: idx_nap Seq_in_index: 1 Column_name: name Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL*************************** 3. row *************************** Table: staffs Non_unique: 1 Key_name: idx_nap Seq_in_index: 2 Column_name: age Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL*************************** 4. row *************************** Table: staffs Non_unique: 1 Key_name: idx_nap Seq_in_index: 3 Column_name: pos Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL4 rows in set (0.01 sec) 全值匹配： 123456789101112131415mysql&gt; explain select * from staffs where name &#x3D; &#39;July&#39; and age &#x3D; &#39;23&#39; and pos&#x3D;&#39;dev&#39;\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: refpossible_keys: idx_nap key: idx_nap key_len: 140 ref: const,const,const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 注意key_len, 利用key_len可以推出用到的索引 140 = { name的varchar(24) + pos的varchar(20) } * 3(utf8字符占三个字节) + int的4 + 每个varchar在存储时会多占用2个字节所以 name + pos (4) 就等于 140 匹配最左前缀： 123456789101112131415mysql&gt; explain select * from staffs where name &#x3D; &#39;July&#39; and age &#x3D; 2\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: refpossible_keys: idx_nap key: idx_nap key_len: 78 # 24 * 3 + 4 + varchar额外占用的2个字节 ref: const,const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 匹配列前缀：like 1234567891011121314151617181920212223242526272829303132# % 符号在后可以触发索引mysql&gt; explain select * from staffs where name like &#39;J%&#39; and age &#x3D; 23\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: rangepossible_keys: idx_nap key: idx_nap key_len: 78 ref: NULL rows: 1 filtered: 100.00 Extra: Using index condition1 row in set, 1 warning (0.00 sec)# % 符号在前无法触发索引mysql&gt; explain select * from staffs where name like &#39;%J%&#39; and age &#x3D; 23\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 匹配范围值：&gt;,&lt; 123456789101112131415mysql&gt; explain select * from staffs where name &gt; &#39;yuxiang&#39;\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: rangepossible_keys: idx_nap key: idx_nap key_len: 74 ref: NULL rows: 1 filtered: 100.00 Extra: Using index condition1 row in set, 1 warning (0.00 sec) 当用到 &gt; 或 &lt; 等范围查询时，在范围查询后面的字段将不会使用索引 事务事务的基本要素1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的并发问题1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 MySQL默认事务隔离级别。 1234567mysql&gt; show variables like &#39;TRANSACTION_isolation&#39;;+-----------------------+-----------------+| Variable_name | Value |+-----------------------+-----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+1 row in set, 1 warning (0.01 sec)&#96;1&#96; 演示 需要将MySQL的事务提交改为手动提交。 1set global autocommit&#x3D;0; 读未提交。。。。。。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/categories/MySQL/"},{"name":"MySQL索引","slug":"MySQL/MySQL索引","permalink":"http://yuxiangai.cn/categories/MySQL/MySQL%E7%B4%A2%E5%BC%95/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/tags/MySQL/"}]},{"title":"redis介绍和使用","slug":"Redis介绍和使用","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2020/10/18/Redis介绍和使用/","link":"","permalink":"http://yuxiangai.cn/2020/10/18/Redis%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"redis的介绍、安装、使用和Liunx高级命令","text":"redis的介绍、安装、使用和Liunx高级命令 环境 Aliyun CentOS Linux 7 Redis 5.X 简介Redis是一个开源（BSD许可），内存中的数据结构存储，用作数据库、缓存和消息代理。它支持诸如字符串、哈希、列表、集合、带范围查询的排序集、位图、超日志、带有radius查询和流的地理空间索引等数据结构。Redis内置了复制、Lua脚本、LRU逐出、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区来提供高可用性。 下载安装12345678# 安装wget工具yum install wget -y# 下载Rediswget https://download.redis.io/releases/redis-5.0.5.tar.gz# 解压缩tar -zxvf redis-5.0.5.tar.gzcd redis-5.0.5 &amp;&amp; ls -lh# 此处推荐查看 README.md文件，该文件介绍了Redis如何安装，也可以按照我的操作进行 123456# 安装环境，否则可能会编译出错yum install gcc -y# 编译，安装，会默认安装到 /usr/local/bin 中make &amp;&amp; make install# 如果编译失败，则使用 make distclean 清楚编译失败的文件# 进入 redis目录中的 utils目录下，执行 ./install_server.sh 根据问题进行操作即可 验证服务启动状态service redis_6379 status 或 systemctl status redis_6379 strace使用strace 是 Linux 环境下的一款程序调试工具，用来监察一个应用程序所使用的系统呼叫及它所接收的系统信息。 123456# 安装yum install strace -y# 在 root 目录下创建 stracedir 文件夹cd ~ &amp;&amp; mkdir stracedir# 启动监控 -ff:监控主线程和所有主线程创建的线程 -o:追踪日志输出目录strace -ff -o ~/stracedir/ooxx ./Redis-server 查看 /root/stracedir文件夹下生成的文件，由名字和线程PID组成。 连接输入redis-cli即可连接 123456789101112131415[root@ctl ~]# redis-cli -h # 查看命令帮助，此处列出一部分redis-cli 5.0.5Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]] -h &lt;hostname&gt; Server hostname (default: 127.0.0.1). -p &lt;port&gt; Server port (default: 6379). -s &lt;socket&gt; Server socket (overrides hostname and port). -a &lt;password&gt; Password to use when connecting to the server. You can also use the REDISCLI_AUTH environment variable to pass this password more safely (if both are used, this argument takes predecence). -u &lt;uri&gt; Server URI. -n &lt;db&gt; Database number. --raw Use raw formatting for replies (default when STDOUT is not a tty). redis五大类型help @[+ tab键] 可查看redis类型的具体操作详解 key 最大可为 512M string1234567891011# object 命令Object &lt;ENCODING|FREQ|IDLETIME|REFCOUNT&gt; &lt;key&gt;127.0.0.1:6379&gt; get str&quot;yu&quot;127.0.0.1:6379&gt; get nu&quot;2&quot;127.0.0.1:6379&gt; object encoding str&quot;embstr&quot;127.0.0.1:6379&gt; object encoding nu&quot;int&quot; bitmap 1234567891011121314151617# setbit 命令 对二进制进行操作SETBIT &lt;key&gt; offset value127.0.0.1:6379&gt; setbit str 1 1 # 0100 0000(integer) 0127.0.0.1:6379&gt; get str&quot;@&quot;127.0.0.1:6379&gt; setbit str 7 1 # 0100 0001(integer) 0127.0.0.1:6379&gt; get str&quot;A&quot;127.0.0.1:6379&gt; setbit str 7 0 (integer) 1127.0.0.1:6379&gt; setbit str 6 1 # 0100 0010(integer) 0127.0.0.1:6379&gt; get str&quot;B&quot; 123456789101112131415# bitcount 命令 对起始字节到结束字节中的二进制位为1的进行统计BITCOUNT key [start end]127.0.0.1:6379&gt; get str # 0100 0010 0100 0000&quot;B@&quot;127.0.0.1:6379&gt; bitcount str 1 1 (integer) 1127.0.0.1:6379&gt; bitcount str 0 1(integer) 3127.0.0.1:6379&gt; setbit str 14 1 # 0100 0010 0100 0010(integer) 0127.0.0.1:6379&gt; bitcount str 1 1(integer) 2127.0.0.1:6379&gt; get str&quot;BB&quot; 12345678910111213# bitpos 命令 获取“起始字节”到“结束字节”的“0”或“1”第一次出现的位置下标 BITPOS key bit [start] [end]127.0.0.1:6379&gt; get str # 0100 0010 0100 0010&quot;BB&quot;127.0.0.1:6379&gt; bitpos str 0 1 1 (integer) 8127.0.0.1:6379&gt; bitpos str 1 1 1(integer) 9127.0.0.1:6379&gt; setbit str 9 0(integer) 1127.0.0.1:6379&gt; bitpos str 1 1 1(integer) 14 123456789101112131415161718192021222324# bitop 命令 BITOP operation destkey key [key ...]operation = [and|or]127.0.0.1:6379&gt; setbit k1 1 1(integer) 0127.0.0.1:6379&gt; setbit k1 7 1(integer) 0127.0.0.1:6379&gt; get k1&quot;A&quot;127.0.0.1:6379&gt; setbit k2 1 1(integer) 0127.0.0.1:6379&gt; setbit k2 6 1(integer) 0127.0.0.1:6379&gt; get k2&quot;B&quot;127.0.0.1:6379&gt; bitop and andkey k1 k2 # 0100 0001 and 0100 0010 = 0100 0000(integer) 1127.0.0.1:6379&gt; get andkey&quot;@&quot;127.0.0.1:6379&gt; bitop or orkey k1 k2 # 0100 0001 or 0100 0010 = 0100 0011(integer) 1127.0.0.1:6379&gt; get orkey&quot;C&quot; 场景解读 &gt; incr接口调用次数 可以利用最大值 - 次数，来指定次数 incr 秒杀场景 bitmap 统计用户一段时间内的登录情况 列：bitmap 用户名 [365 1]，[25 1]即为 一年中的第25天和365天登录了 bitmap 20201019 用户名id 1，即为该用户在20201019号这一天有登录 bitmap 20201020 用户名id 1，即为该用户在20201020号这一天有登录 之后使用 bitop or 19-20 20201019 20201020来统计某时间段内的活跃用户 list123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869127.0.0.1:6379&gt; help @list BLPOP key [key ...] timeout summary: Remove and get the first element in a list, or block until one is available since: 2.0.0 BRPOP key [key ...] timeout summary: Remove and get the last element in a list, or block until one is available since: 2.0.0 BRPOPLPUSH source destination timeout summary: Pop a value from a list, push it to another list and return it; or block until one is available since: 2.2.0 LINDEX key index summary: Get an element from a list by its index since: 1.0.0 LINSERT key BEFORE|AFTER pivot value summary: Insert an element before or after another element in a list since: 2.2.0 LLEN key summary: Get the length of a list since: 1.0.0 LPOP key summary: Remove and get the first element in a list since: 1.0.0 LPUSH key value [value ...] summary: Prepend one or multiple values to a list since: 1.0.0 LPUSHX key value summary: Prepend a value to a list, only if the list exists since: 2.2.0 LRANGE key start stop summary: Get a range of elements from a list since: 1.0.0 LREM key count value summary: Remove elements from a list since: 1.0.0 LSET key index value summary: Set the value of an element in a list by its index since: 1.0.0 LTRIM key start stop summary: Trim a list to the specified range since: 1.0.0 RPOP key summary: Remove and get the last element in a list since: 1.0.0 RPOPLPUSH source destination summary: Remove the last element in a list, prepend it to another list and return it since: 1.2.0 RPUSH key value [value ...] summary: Append one or multiple values to a list since: 1.0.0 RPUSHX key value summary: Append a value to a list, only if the list exists since: 2.2.0 场景解读 &gt; 可以当：栈、队列、数组 ltrim热评论 hash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061127.0.0.1:6379&gt; help @hash HDEL key field [field ...] summary: Delete one or more hash fields since: 2.0.0 HEXISTS key field summary: Determine if a hash field exists since: 2.0.0 HGET key field summary: Get the value of a hash field since: 2.0.0 HGETALL key summary: Get all the fields and values in a hash since: 2.0.0 HINCRBY key field increment summary: Increment the integer value of a hash field by the given number since: 2.0.0 HINCRBYFLOAT key field increment summary: Increment the float value of a hash field by the given amount since: 2.6.0 HKEYS key summary: Get all the fields in a hash since: 2.0.0 HLEN key summary: Get the number of fields in a hash since: 2.0.0 HMGET key field [field ...] summary: Get the values of all the given hash fields since: 2.0.0 HMSET key field value [field value ...] summary: Set multiple hash fields to multiple values since: 2.0.0 HSCAN key cursor [MATCH pattern] [COUNT count] summary: Incrementally iterate hash fields and associated values since: 2.8.0 HSET key field value summary: Set the string value of a hash field since: 2.0.0 HSETNX key field value summary: Set the value of a hash field, only if the field does not exist since: 2.0.0 HSTRLEN key field summary: Get the length of the value of a hash field since: 3.2.0 HVALS key summary: Get all the values in a hash since: 2.0.0 场景解读 &gt; 商品详情页利用filed聚合数据 set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061127.0.0.1:6379&gt; help @set SADD key member [member ...] summary: Add one or more members to a set since: 1.0.0 SCARD key summary: Get the number of members in a set since: 1.0.0 SDIFF key [key ...] summary: Subtract multiple sets since: 1.0.0 SDIFFSTORE destination key [key ...] summary: Subtract multiple sets and store the resulting set in a key since: 1.0.0 SINTER key [key ...] summary: Intersect multiple sets since: 1.0.0 SINTERSTORE destination key [key ...] summary: Intersect multiple sets and store the resulting set in a key since: 1.0.0 SISMEMBER key member summary: Determine if a given value is a member of a set since: 1.0.0 SMEMBERS key summary: Get all the members in a set since: 1.0.0 SMOVE source destination member summary: Move a member from one set to another since: 1.0.0 SPOP key [count] summary: Remove and return one or multiple random members from a set since: 1.0.0 SRANDMEMBER key [count] # count&gt;0时，返回集合会去重，count&lt;0时，返回集合不会去重 summary: Get one or multiple random members from a set since: 1.0.0 SREM key member [member ...] summary: Remove one or more members from a set since: 1.0.0 SSCAN key cursor [MATCH pattern] [COUNT count] summary: Incrementally iterate Set elements since: 2.8.0 SUNION key [key ...] summary: Add multiple sets since: 1.0.0 SUNIONSTORE destination key [key ...] summary: Add multiple sets and store the resulting set in a key since: 1.0.0 场景解读 &gt; 抽奖 spop 随机算出一个 简单推荐系统 利用两个set集合进行并集或交集的操作；sdiff sorted_set特点： 去重、有序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293127.0.0.1:6379&gt; help @sorted_set ZADD key [NX|XX] [CH] [INCR] score member [score member ...] summary: Add one or more members to a sorted set, or update its score if it already exists since: 1.2.0 ZCARD key summary: Get the number of members in a sorted set since: 1.2.0 ZCOUNT key min max summary: Count the members in a sorted set with scores within the given values since: 2.0.0 ZINCRBY key increment member summary: Increment the score of a member in a sorted set since: 1.2.0 ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] summary: Intersect multiple sorted sets and store the resulting sorted set in a new key since: 2.0.0 ZLEXCOUNT key min max summary: Count the number of members in a sorted set between a given lexicographical range since: 2.8.9 ZPOPMAX key [count] summary: Remove and return members with the highest scores in a sorted set since: 5.0.0 ZPOPMIN key [count] summary: Remove and return members with the lowest scores in a sorted set since: 5.0.0 ZRANGE key start stop [WITHSCORES] summary: Return a range of members in a sorted set, by index since: 1.2.0 ZRANGEBYLEX key min max [LIMIT offset count] summary: Return a range of members in a sorted set, by lexicographical range since: 2.8.9 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] summary: Return a range of members in a sorted set, by score since: 1.0.5 ZRANK key member # 返回排名 summary: Determine the index of a member in a sorted set since: 2.0.0 ZREM key member [member ...] summary: Remove one or more members from a sorted set since: 1.2.0 ZREMRANGEBYLEX key min max summary: Remove all members in a sorted set between the given lexicographical range since: 2.8.9 ZREMRANGEBYRANK key start stop summary: Remove all members in a sorted set within the given indexes since: 2.0.0 ZREMRANGEBYSCORE key min max summary: Remove all members in a sorted set within the given scores since: 1.2.0 ZREVRANGE key start stop [WITHSCORES] summary: Return a range of members in a sorted set, by index, with scores ordered from high to low since: 1.2.0 ZREVRANGEBYLEX key max min [LIMIT offset count] summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings. since: 2.8.9 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] summary: Return a range of members in a sorted set, by score, with scores ordered from high to low since: 2.2.0 ZREVRANK key member summary: Determine the index of a member in a sorted set, with scores ordered from high to low since: 2.0.0 ZSCAN key cursor [MATCH pattern] [COUNT count] summary: Incrementally iterate sorted sets elements and associated scores since: 2.8.0 ZSCORE key member summary: Get the score associated with the given member in a sorted set since: 1.2.0 ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] summary: Add multiple sorted sets and store the resulting sorted set in a new key since: 2.0.0 场景解读 &gt; 排行榜 通用命令key的时效性控制 123456789101112# 为指定key设置有效期expire key secondspexpire key millisecondsexpireat key timestamppexpireat key milliseconds-timestamp# 获取key的有效时间ttl key # 返回-2 不存在，返回-1 存在，返回key的剩余时间pttl key# 切换key从时效性转为永久性persist key 数据库操作 12345678# 选择数据库 0-15select &lt;index&gt;# 数据移动move key &lt;dbindex&gt;# 查看当前库有多少个keydbsize 持久化RDBAOF","categories":[{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/categories/redis/"},{"name":"redis使用","slug":"redis/redis使用","permalink":"http://yuxiangai.cn/categories/redis/redis%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/tags/redis/"}]},{"title":"MySQL之PXC集群","slug":"MySQL之PXC集群","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2020/10/14/MySQL之PXC集群/","link":"","permalink":"http://yuxiangai.cn/2020/10/14/MySQL%E4%B9%8BPXC%E9%9B%86%E7%BE%A4/","excerpt":"Docker环境下，部署MySQL之PXC集群的操作","text":"Docker环境下，部署MySQL之PXC集群的操作 环境 Aliyun CentOS Linux 7 Docker Version 19.03.12 Docker Image percona/percona-xtradb-cluster:5.7 实践1.下载MySQL镜像1docker pull percona/percona-xtradb-cluster:5.7 2.重命名镜像1docker tag percona/percona-xtradb-cluster:5.7 pxc:5.7 3.创建数据卷注： pxc 只支持数据卷，不支持挂载目录 12345docker volume create v1docker volume create v1docker volume create v1# 查看数据卷创建情况docker volume ls 4.创建网络，用于 pxc集群123docker network create pxc-network# 查看Docker 网络docker network ls 5.运行第一个MySQL实例节点123456docker run -di --name=pn1 \\--net=pxc-network -p 9000:3306 \\-v v1:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 pxc:5.7 查看是否创建成功 1docker logs pn1 出现下面情况测启动成功 2020-10-15T01:39:47.933208Z 0 [Note] InnoDB: Buffer pool(s) load completed at 201015 1:39:47 6.运行第二个MySQL实例节点1234567docker run -di --name=pn2 \\--net=pxc-network -p 9001:3306 \\-v v2:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn1 pxc:5.7 从第二个节点开始，就需要增加cluster_join 来指定与其进行数据同步的节点。当 PXC集群中存在两个节点以上之后就没有主节点的概念了。集群中最后一个退出的节点就会变为主节点，在/var/lib/mysql/grastate.dat 文件中属性 safe_to_bootstrap 的值 会从 0 被设置为 1 表示该节点是主节点。 7.运行第三个MySQL实例节点1234567docker run -di --name=pn3 \\--net=pxc-network -p 9002:3306 \\-v v3:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn2 pxc:5.7 这次我们指定cluster_join=pn2,可以证明当集群中有两个以上的节点时，就没有主节点的概念了。 8.进入 pn1节点123docker exec -it pn1 /bin/bash# 连接mysqlmysql -uroot -p123456 9.查看状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677mysql&gt; show status like &quot;wsrep%&quot;;+----------------------------------+-------------------------------------------------------+| Variable_name | Value |+----------------------------------+-------------------------------------------------------+| wsrep_local_state_uuid | 81380d49-0dd6-11eb-aa93-028f13d687c0 || wsrep_protocol_version | 9 || wsrep_last_applied | 25 || wsrep_last_committed | 25 || wsrep_replicated | 0 || wsrep_replicated_bytes | 0 || wsrep_repl_keys | 0 || wsrep_repl_keys_bytes | 0 || wsrep_repl_data_bytes | 0 || wsrep_repl_other_bytes | 0 || wsrep_received | 4 || wsrep_received_bytes | 656 || wsrep_local_commits | 0 || wsrep_local_cert_failures | 0 || wsrep_local_replays | 0 || wsrep_local_send_queue | 0 || wsrep_local_send_queue_max | 1 || wsrep_local_send_queue_min | 0 || wsrep_local_send_queue_avg | 0.000000 || wsrep_local_recv_queue | 0 || wsrep_local_recv_queue_max | 2 || wsrep_local_recv_queue_min | 0 || wsrep_local_recv_queue_avg | 0.250000 || wsrep_local_cached_downto | 0 || wsrep_flow_control_paused_ns | 0 || wsrep_flow_control_paused | 0.000000 || wsrep_flow_control_sent | 0 || wsrep_flow_control_recv | 0 || wsrep_flow_control_interval | [ 173, 173 ] || wsrep_flow_control_interval_low | 173 || wsrep_flow_control_interval_high | 173 || wsrep_flow_control_status | OFF || wsrep_cert_deps_distance | 0.000000 || wsrep_apply_oooe | 0.000000 || wsrep_apply_oool | 0.000000 || wsrep_apply_window | 0.000000 || wsrep_commit_oooe | 0.000000 || wsrep_commit_oool | 0.000000 || wsrep_commit_window | 0.000000 || wsrep_local_state | 4 || wsrep_local_state_comment | Synced || wsrep_cert_index_size | 0 || wsrep_cert_bucket_count | 22 || wsrep_gcache_pool_size | 1320 || wsrep_causal_reads | 0 || wsrep_cert_interval | 0.000000 || wsrep_open_transactions | 0 || wsrep_open_connections | 0 || wsrep_ist_receive_status | || wsrep_ist_receive_seqno_start | 0 || wsrep_ist_receive_seqno_current | 0 || wsrep_ist_receive_seqno_end | 0 || wsrep_incoming_addresses | a3faa8d63239:3306,254c483efa2d:3306,4745baee323f:3306 || wsrep_cluster_weight | 3 || wsrep_desync_count | 0 || wsrep_evs_delayed | || wsrep_evs_evict_list | || wsrep_evs_repl_latency | 0&#x2F;0&#x2F;0&#x2F;0&#x2F;0 || wsrep_evs_state | OPERATIONAL || wsrep_gcomm_uuid | 8b7301c0-0dd6-11eb-b180-07c4552aa3e6 || wsrep_cluster_conf_id | 3 || wsrep_cluster_size | 3 || wsrep_cluster_state_uuid | 81380d49-0dd6-11eb-aa93-028f13d687c0 || wsrep_cluster_status | Primary || wsrep_connected | ON || wsrep_local_bf_aborts | 0 || wsrep_local_index | 1 || wsrep_provider_name | Galera || wsrep_provider_vendor | Codership Oy &lt;info@codership.com&gt; || wsrep_provider_version | 3.45(ra60e019) || wsrep_ready | ON |+----------------------------------+-------------------------------------------------------+71 rows in set (0.03 sec) wsrep_incoming_addresses 属性 对应的就是三台机器的实例ID。 1| wsrep_incoming_addresses | a3faa8d63239:3306,254c483efa2d:3306,4745baee323f:3306 | 集群完整性检查： 属性 含义 wsrep_cluster_state_uuid 在集群所有节点的值应该是相同的,有不同值的节点,说明其没有连接入集群. wsrep_cluster_conf_id 正常情况下所有节点上该值是一样的.如果值不同,说明该节点被临时”分区”了.当节点之间网络连接恢复 的时候应该会恢复一样的值. wsrep_cluster_size 如果这个值跟预期的节点数一致,则所有的集群节点已经连接. wsrep_cluster_status 集群组成的状态.如果不为”Primary”,说明出现”分区”或是”split-brain”脑裂状况. 节点状态检查： 属性 含义 wsrep_ready 该值为 ON,则说明可以接受 SQL 负载.如果为 Off,则需要检查 wsrep_connected wsrep_connected 如果该值为 Off,且 wsrep_ready 的值也为 Off,则说明该节点没有连接到集群.(可能是 wsrep_cluster_address 或 wsrep_cluster_name 等配置错造成的.具体错误需要查看错误日志) wsrep_local_state_comment 如果 wsrep_connected 为 On,但 wsrep_ready 为 OFF,则可以从该项查看原因 复制健康检查: 属性 含义 wsrep_flow_control_paused 表示复制停止了多长时间.即表明集群因为 Slave 延迟而慢的程度.值为 0~1,越靠近 0 越好,值为 1 表示 复制完全停止.可优化 wsrep_slave_threads 的值来改善 wsrep_cert_deps_distance 有多少事务可以并行应用处理.wsrep_slave_threads 设置的值不应该高出该值太多 wsrep_flow_control_sent 表示该节点已经停止复制了多少次 *wsrep_local_recv_queue_avg 表示 slave 事务队列的平均长度.slave 瓶颈的预兆. 最慢的节点的 wsrep_flow_control_sent 和 wsrep_local_recv_queue_avg 这两个值最高.这两个值较低的话,相对更好 检测慢网络问题： 属性 含义 wsrep_local_send_queue_avg 网络瓶颈的预兆.如果这个值比较高的话,可能存在网络瓶颈 冲突或死锁的数目: 属性 含义 wsrep_last_committed 最后提交的事务数目 wsrep_local_cert_failures 和 wsrep_local_bf_aborts 回滚,检测到的冲突数目 集群同步验证验证集群搭建。 在节点 pn1创建数据库pxc_test 12mysql&gt; create database pxc_test; Query OK, 1 row affected (0.05 sec) 在节点pn2中查看数据库psc_test 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || pxc_test || sys || test |+--------------------+6 rows in set (0.02 sec) 在节点pn2上创建sys_user表 1234mysql&gt; use pxc_test;Database changedmysql&gt; create table sys_user ( id int primary key, name varchar(255));Query OK, 0 rows affected (0.03 sec) 在节点pn3上查看表 1234567mysql&gt; show tables;+--------------------+| Tables_in_pxc_test |+--------------------+| sys_user |+--------------------+1 row in set (0.00 sec) 在sys_user上创建数据 12345678910mysql&gt; insert into sys_user values(1,&quot;yuxiang&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.01 sec) 在pn1和pn2上查看数据 1234567mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.02 sec) 可以看到三个节点数据正常同步，并且都可读可写。 新增集群节点操作当数据库不够用时，我们通常需要增加数据库节点来分担压力，我们来演示一下新增节点的操作。 创建数据卷 1docker volume create v4 运行第四个MySQL实例容器 1234567docker run -di --name=pn4 \\--net=pxc-network -p 9003:3306 \\-v v4:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn3 pxc:5.7 这次cluster_join指定的容器是pn3。 进入pn4节点，查看数据 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || pxc_test || sys || test |+--------------------+6 rows in set (0.03 sec) 1234567mysql&gt; show tables;+--------------------+| Tables_in_pxc_test |+--------------------+| sys_user |+--------------------+1 row in set (0.00 sec) 1234567mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.01 sec) 在pn4上添加数据 1234567891011mysql&gt; insert into sys_user values(2,&quot;pxc_pn4&quot;);Query OK, 1 row affected (0.31 sec)mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang || 2 | pxc_pn4 |+----+---------+2 rows in set (0.00 sec) 在其他节点查看，数据也都同步了。 模拟宕机操作 将pn4关闭 1docker stop pn4 在pn1中插入数据 123456789101112mysql&gt; insert into sys_user values(3, &quot;down_online&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from sys_user;+----+-------------+| id | name |+----+-------------+| 1 | yuxiang || 2 | pxc_pn4 || 3 | down_online |+----+-------------+3 rows in set (0.21 sec) 重新启动pn4 1docker start pn4 查看数据 123456789mysql&gt; select * from sys_user;+----+-------------+| id | name |+----+-------------+| 1 | yuxiang || 2 | pxc_pn4 || 3 | down_online |+----+-------------+3 rows in set (0.01 sec) 数据依然同步上了 ps：当所有节点全部宕机时，需从pn1节点启动，如果pn1不是最后一个宕机的，他的volume下的grastate.dat中的safe_to_bootstrap: 0,则无法启动，需要手动将该属性值改为safe_to_bootstrap: 1","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/categories/MySQL/"},{"name":"PXC集群","slug":"MySQL/PXC集群","permalink":"http://yuxiangai.cn/categories/MySQL/PXC%E9%9B%86%E7%BE%A4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yuxiangai.cn/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/tags/MySQL/"}]},{"title":"zookeeper分布式锁","slug":"Zookeeper分布式锁","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2020/09/29/Zookeeper分布式锁/","link":"","permalink":"http://yuxiangai.cn/2020/09/29/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"Zookeeper实现分布式锁实战","text":"Zookeeper实现分布式锁实战 介绍Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 下载安装进入Zookeeper官网 下载最新版，并解压缩 启动在安装目录下 conf目录 中将zoo_sample.cfg 复制一份，命名为 zoo.cfg 12# 将**zoo.cfg**中的 dataDir属性值 修改为 &quot;安装路径&quot; + &quot;/data&quot;dataDir=D://zookeeper//apache-zookeeper-3.6.2-bin//data 启动 ./bin目录下 zkServer.cmd zkCli.cmd 命令 基本操作12345678910# create 结点 值 (创建结点和值，默认创建永久结点)create /service-user 8001# ls 结点 (查看结点下其他结点)ls /service-user# set 结点 (更改结点信息)set /service-user &#123;&quot;port&quot;:80,&quot;url&quot;:&quot;http://yuxiangai.cn&quot;&#125;# get 结点 (得到对应结点的值)get /servie-user# delete 结点 (删除结点和对应值)delete /servie-user zookeeper的结点默认是永久的，即当你断开连接后，你所创建的结点依然存在，我们可以在创建时 加入参数 -e 来指定为临时结点，当断开连接时，创建的结点会被清除 zookeeper的结点默认是唯一的，即相同名称的结点只有一个，我们可以加 -s 来给结点增加顺序，看下图 代码实现创建Maven项目 ，在Pom.xml文件中添加依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.11&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 定义接口 12345678910package com.yuxiang.adl.lock;public interface ZKLock &#123; // 加锁 void lock(); // 释放锁 void unlock();&#125; 定义抽象类 123456789101112131415161718192021222324252627282930313233343536package com.yuxiang.adl.lock;import org.I0Itec.zkclient.ZkClient;import java.util.concurrent.CountDownLatch;public abstract class ZKAbstractTemplateLock implements ZKLock&#123; protected static final String ZK_SERVER = &quot;localhost:2181&quot;; protected static final int ZK_TIMEOUT = 45 * 1000; protected ZkClient client = new ZkClient(ZK_SERVER, ZK_TIMEOUT); protected static String PATH = &quot;/service-order&quot;; protected CountDownLatch countDownLatch = null; @Override public void lock() &#123; if (tryZKLock()) &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t 占有锁成功&quot;); &#125; else &#123; waitZkLock(); lock(); &#125; &#125; @Override public void unlock() &#123; if (client != null) &#123; client.close(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t 释放锁成功&quot;); &#125; // 尝试加锁 protected abstract boolean tryZKLock(); // 加锁失败则等待 protected abstract void waitZkLock();&#125; 定义实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yuxiang.adl.lock;import org.I0Itec.zkclient.IZkDataListener;import java.util.concurrent.CountDownLatch;public class ZKDistributedLock extends ZKAbstractTemplateLock&#123; @Override protected boolean tryZKLock() &#123; try &#123; client.createEphemeral(PATH); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; @Override protected void waitZkLock() &#123; IZkDataListener iZkDataListener = new IZkDataListener() &#123; @Override public void handleDataChange(String s, Object o) throws Exception &#123; &#125; @Override public void handleDataDeleted(String s) throws Exception &#123; if (countDownLatch != null) &#123; countDownLatch.countDown(); &#125; &#125; &#125;; client.subscribeDataChanges(PATH, iZkDataListener); if (client.exists(PATH)) &#123; // 如果存在该节点，只能等着 countDownLatch = new CountDownLatch(1); try &#123; countDownLatch.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; client.unsubscribeDataChanges(PATH, iZkDataListener); &#125;&#125; 生成订单工具类 12345678package com.yuxiang.adl.util;public class OrderNumCreateUtil &#123; private static int number = 0; public String getOrderNumber() &#123; return &quot;\\t 生成订单号： &quot; + (++number); &#125;&#125; idea,5. 订单生成服务 1234567891011121314151617181920212223package com.yuxiang.adl.service;import com.yuxiang.adl.lock.ZKDistributedLock;import com.yuxiang.adl.lock.ZKLock;import com.yuxiang.adl.util.OrderNumCreateUtil;public class OrderService &#123; private OrderNumCreateUtil orderNumCreateUtil = new OrderNumCreateUtil(); private ZKLock zkLock = new ZKDistributedLock(); public void getOrderNumber() &#123; zkLock.lock(); try &#123; System.out.println(orderNumCreateUtil.getOrderNumber()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; zkLock.unlock(); &#125; &#125;&#125; Main方法 123456789101112131415package com.yuxiang.adl;import com.yuxiang.adl.service.OrderService;public class ZookeeperMain &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; new OrderService().getOrderNumber(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 类关系图","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/categories/zookeeper/"},{"name":"zookeeper分布式锁","slug":"zookeeper/zookeeper分布式锁","permalink":"http://yuxiangai.cn/categories/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/tags/zookeeper/"}]},{"title":"Gradle的下载安装与配置","slug":"Gradle的下载安装与配置","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2020/09/22/Gradle的下载安装与配置/","link":"","permalink":"http://yuxiangai.cn/2020/09/22/Gradle%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Maven的下载安装、配置及简单使用","text":"Maven的下载安装、配置及简单使用 简介Gradle是是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 面向Java应用为主。当前其支持的语言限于Java、Groovy、Kotlin和Scala，计划未来将支持更多的语言。 下载下载页面 : https://services.gradle.org/distributions 下载gradle-x.x-bin.zip(发行版) 可以自选版本，我这里选择之前的版本 gradle-5.4-bin.zip ，解压缩，放到指定目录。 配置环境变量在 此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建 变量值为Gradle的文件安装位置 修改path变量，将Gradle的bin 【%GRADLE_HOME%\\bin】添加到变量之中 在命令窗口中输出 【gradle -v】查看是否安装成功 配置本地仓库和镜像加速Gradle第一次下载文件需要到远程仓库下载，这样很慢，我们可以在本地配置一个仓库，这样第二次直接在本地加载，速度飕飕的。 还是在 此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建 在Gradle安装目录下的init.d文件中新建文件 init.gradle 输入以下内容： 1234567891011121314151617allprojects &#123; repositories &#123; maven &#123; url &#x27;file:///D:/gradlerepository&#x27;&#125; maven &#123; name &quot;Alibaba&quot; ; url &quot;https://maven.aliyun.com/repository/public&quot; &#125; mavenLocal() maven &#123; name &quot;Bstek&quot; ; url &quot;http://nexus.bsdn.org/content/groups/public/&quot; &#125; mavenCentral() &#125; buildscript &#123; repositories &#123; maven &#123; name &quot;Alibaba&quot; ; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125; maven &#123; name &quot;Bstek&quot; ; url &#x27;http://nexus.bsdn.org/content/groups/public/&#x27; &#125; maven &#123; name &quot;M2&quot; ; url &#x27;https://plugins.gradle.org/m2/&#x27; &#125; &#125; &#125;&#125; IntelliJ IDEA配置Gradle选择 file -&gt; setting 搜索 gradle 测试 创建Gradle项目 file -&gt; new -&gt; Project ,选择Gradle 填写项目名和 groupid、artifactid, version, 点击 Finish 添加 build.gradle文件中添加Spring 依赖，测试运行Spring项目 123456789101112131415group &#x27;com.yuxiang&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenLocal() mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; // https://mvnrepository.com/artifact/org.springframework/spring-context compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-context&#x27;, version: &#x27;5.2.5.RELEASE&#x27;&#125; 主类 1234567891011121314151617181920212223242526package com.yuxiang;import com.yuxiang.service.BaseService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;public class SpringMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ServiceConfig.class); BaseService baseService = (BaseService) context.getBean(&quot;baseService&quot;); Integer integer = baseService.show(10); System.out.println(integer); &#125;&#125;@ComponentScan(&quot;com.yuxiang&quot;)@Configurationclass ServiceConfig &#123;&#125; 接口 1234567package com.yuxiang.service;public interface BaseService &#123; Integer show(Integer value);&#125; 实现类 123456789101112package com.yuxiang.service.impl;import com.yuxiang.service.BaseService;import org.springframework.stereotype.Component;@Component(&quot;baseService&quot;)public class BaseServiceImpl implements BaseService &#123; @Override public Integer show(Integer value) &#123; return value * value; &#125;&#125; 运行结果","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Gradle","slug":"项目构建/Gradle","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://yuxiangai.cn/tags/Gradle/"}]},{"title":"go语言之框架Gin的简单使用","slug":"Go语言之框架Gin的简单使用","date":"un55fin55","updated":"un11fin11","comments":false,"path":"2020/07/10/Go语言之框架Gin的简单使用/","link":"","permalink":"http://yuxiangai.cn/2020/07/10/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A1%86%E6%9E%B6Gin%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"go语言之框架Gin的简单使用","text":"go语言之框架Gin的简单使用 环境 GoLang SDK 1.14 实践创建项目 在go.mod中引入gin依赖12345module &quot;go-gin-projectall&quot;go 1.14require github.com&#x2F;gin-gonic&#x2F;gin v1.6.3 简单例子123456789101112131415161718192021package mainimport &quot;github.com/gin-gonic/gin&quot;// 第一种方式func hello(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Hello &quot;, &#125;)&#125;func main() &#123; g := gin.Default() // 第二种方式 g.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Hello World&quot;, &#125;) &#125;) g.GET(&quot;/hello&quot;, hello) g.Run(&quot;:8666&quot;)&#125; 启动访问测试 Resultful风格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; g := gin.Default() g.GET(&quot;/get&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Get Request url=/get&quot;, &#125;) &#125;) g.POST(&quot;/post&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Post Request url=/post&quot;, &#125;) &#125;) g.DELETE(&quot;/delete&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Delete Request url=/delete&quot;, &#125;) &#125;) g.PUT(&quot;/put&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Put Request url=/put&quot;, &#125;) &#125;) // 匹配该路径的任何请求 g.Any(&quot;/any&quot;, func(c *gin.Context) &#123; switch c.Request.Method &#123; // 注意大写 case &quot;GET&quot;: c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;url=/any method=get&quot;&#125;) case http.MethodPost: c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;url=/any method=Post&quot;&#125;) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;Any&quot;, &#125;) &#125;) // 当没有找到匹配路径时触发 g.NoRoute(func(c *gin.Context) &#123; c.JSON(http.StatusNotFound,gin.H&#123;&quot;message&quot;: &quot;Not Found&quot;&#125;) &#125;) g.Run(&quot;:8666&quot;)&#125; 路由组123456789101112131415161718192021222324252627import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; g := gin.Default() authGroup := g.Group(&quot;/auth&quot;, func(c *gin.Context) &#123; // 当组内路径匹配时 会触发该方法 c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;url=/auth &quot;&#125;) &#125;) // 方便阅读，用一对&#123;&#125;包裹起来 &#123; // 访问路径 /auth/token authGroup.GET(&quot;/token&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Get ok&quot;&#125;) &#125;) // 访问路径 /auth/token authGroup.POST(&quot;/token&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Post ok&quot;&#125;) &#125;) &#125; g.Run(&quot;:8666&quot;)&#125; 获取上传参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;path&quot;)// UserInfo 用户信息实体type UserInfo struct &#123; Username string `form:&quot;username&quot;, json:&quot;username&quot;` Password string `form:&quot;password&quot;, json:&quot;password&quot;`&#125;func main() &#123; g := gin.Default() // 获取url中传递的参数 列：baidu.com/search?query=go语言 g.GET(&quot;/search&quot;, func(c *gin.Context) &#123; name := c.Query(&quot;query&quot;) query := c.DefaultQuery(&quot;query&quot;, &quot;当没有获取到值时，则当前为默认值&quot;) // str, isNotNull := c.GetQuery(&quot;query&quot;) // 当有值时，isNotNull=true，否则为 false c.JSON(200, gin.H&#123; &quot;keyWord&quot;: name, &quot;默认值&quot;: query, &#125;) &#125;) // 获取post方式表单提交的参数 g.POST(&quot;/login&quot;, func(c *gin.Context) &#123; user := c.PostForm(&quot;user&quot;) pwd := c.PostForm(&quot;pwd&quot;) code := c.DefaultPostForm(&quot;code&quot;, &quot;123456&quot;) c.JSON(200, gin.H&#123; &quot;post&quot;: true, &quot;user&quot;: user, &quot;pwd&quot;: pwd, &quot;code&quot;: code, &#125;) &#125;) // 获取url路径参数 g.GET(&quot;/mysql/:root/:pwd&quot;, func(c *gin.Context) &#123; root := c.Param(&quot;root&quot;) pwd := c.Param(&quot;pwd&quot;) c.JSON(200, gin.H&#123; &quot;root&quot;: root, &quot;pwd&quot;: pwd, &#125;) &#125;) // 获取数据封装为实体类 g.POST(&quot;/register&quot;, func(c *gin.Context) &#123; var u UserInfo err := c.ShouldBind(&amp;u) if err != nil &#123; fmt.Printf(&quot;bindfail %#v \\n&quot;, err) &#125; c.JSON(200, gin.H&#123; &quot;root&quot;: u.Username, &quot;pwd&quot;: u.Password, &#125;) &#125;) // 文件上传 g.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; file, _ := c.FormFile(&quot;file&quot;) //form, _ := c.MultipartForm() 上传多个文件时，使用该方法 c.JSON(200, &quot;ok&quot;) // 拼接存储路径 filePath := path.Join(&quot;./&quot;, file.Filename) // 存储 c.SaveUploadedFile(file, filePath) &#125;) g.Run(&quot;:8666&quot;)&#125; 请求转发和重定向12345678910111213141516171819202122232425func main() &#123; g := gin.Default() // 请求重定向 g.GET(&quot;/baidu&quot;, func(c *gin.Context) &#123; // 重定向 c.Redirect(http.StatusMovedPermanently, &quot;https://baidu.com&quot;) &#125;) // 请求转发 g.GET(&quot;/a&quot;, func(c *gin.Context) &#123; // 改变下一条路径 c.Request.URL.Path = &quot;/b&quot; // 注意 对象g g.HandleContext(c) &#125;) g.GET(&quot;/b&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;OK&quot;, &#125;) &#125;) g.Run(&quot;:8666&quot;)&#125; 返回HTML页面和模板解析目录结构如下 12345678910111213141516171819202122232425262728293031import ( &quot;github.com/gin-gonic/gin&quot; &quot;html/template&quot; &quot;net/http&quot;)func main() &#123; g := gin.Default() // 自定义模板解析函数 g.SetFuncMap(template.FuncMap&#123; &quot;safe&quot;: func(str string) template.HTML&#123; return template.HTML(str) &#125;, &#125;) // 扫描并加载模板 此方法要写在 SetFuncMap()方法之下，否则会出错 g.LoadHTMLGlob(&quot;./templates/**/*&quot;) g.GET(&quot;/ihtml&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;index/index.tmpl&quot;, gin.H&#123; &quot;title&quot;: &quot;&lt;a href=&#x27;www.baidu.com&#x27;&gt;百度&lt;/a&gt;&quot;, &#125;) &#125;) g.GET(&quot;/uhtml&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;user/index.tmpl&quot;, gin.H&#123; &quot;title&quot;: &quot;&lt;a href=&#x27;www.baidu.com&#x27;&gt;百度&lt;/a&gt;&quot;, &#125;) &#125;) g.Run(&quot;:8666&quot;)&#125; define &quot;name&quot; 用来定义该模板名称 123456789101112&#123;&#123; define &quot;index&#x2F;index.tmpl&quot;&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;Index Index ， &#123;&#123; .title &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#123;&#123;end&#125;&#125; 1234567891011121314&#123;&#123; define &quot;user&#x2F;index.tmpl&quot;&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &#123;&#123;&#x2F;* “.” 代表传入的对象名 “.属性名” 可以拿到传递过来value值 *&#x2F;&#125;&#125; &#123;&#123;&#x2F;* 使用自定义模板解析函数 “ | safe” *&#x2F;&#125;&#125; &lt;h1&gt;Users Index ， &#123;&#123; .title | safe&#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#123;&#123;end&#125;&#125; 加载静态文件在 &quot;index/index.tmpl&quot; 文件中引入 css文件和js文件 12&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/index.css&quot;&gt;&lt;script rel=&quot;script&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt; /resources/static/css/index.css 123h1 &#123; color: red;&#125; /resources/static/js/index.js 12var url = location.pathnamealert(url) 1234// 当静态资源访问路劲中有&#x27;参数1&#x27;的值时，则从&#x27;参数2&#x27;目录中找对应文件g.Static(&quot;/static/css&quot;, &quot;./resources/statics/css&quot;)g.Static(&quot;/static/js&quot;, &quot;./resources/statics/js&quot;)g.StaticFile(&quot;/favicon.ico&quot;, &quot;./resources/favicon.ico&quot;) 后续……","categories":[{"name":"golang","slug":"golang","permalink":"http://yuxiangai.cn/categories/golang/"},{"name":"gin","slug":"golang/gin","permalink":"http://yuxiangai.cn/categories/golang/gin/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://yuxiangai.cn/tags/Go/"},{"name":"Gin","slug":"Gin","permalink":"http://yuxiangai.cn/tags/Gin/"}]},{"title":"Maven的下载安装与配置","slug":"Maven的下载安装与配置","date":"un44fin44","updated":"un11fin11","comments":false,"path":"2020/07/09/Maven的下载安装与配置/","link":"","permalink":"http://yuxiangai.cn/2020/07/09/Maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Maven的下载安装、配置及简单使用","text":"Maven的下载安装、配置及简单使用 Maven简介Apache Maven是一个软件项目管理和理解工具。基于项目对象模型（POM）的概念，Maven可以从中央信息管理项目的构建，报告和文档。 Maven下载点击 Download进行下载 选择二进制下载，版本为3.6.3 Maven安装 解压缩之后目录 配置系统环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;新建 在path 环境变量后添加 %MAVEN_HOME%/bin 12# 查看Maven是否安装成功，使用命令mvn -version 配置本地仓库首先，我们要知道什么是仓库，详情可参考菜鸟教程 简单来说，就是“我”安装了一个软件叫Maven，当”我“输入一个jar包的名字，让Maven这个软件去帮我下载，从而不用自己再去Maven仓库手动下载。 但是，Maven默认是去中央仓库下载jar包，而中央仓库又是在国外，访问会很慢，所以配置一个本地仓库，将远程仓库的jar包下载并保存到本地，这样当下次再使用时就不用到国外去下载了，速度飕飕的。 在Maven根目录中打开conf/settings.xml，配置 localRepository，写自己创建的文件路径即可 配置阿里云镜像加速即使配置了本地仓库，第一次去国外下载依旧很慢，我们可以配置为阿里云仓库 打开Maven根目录中的conf/settings.xml文件，在 mirrors 节点上，添加内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; IntelliJ IDEA配置Maven打开IntelliJ IDEA，选择 file&gt;settings&gt;Build,Execution,Deployment&gt;Build Tools&gt;Maven 创建Maven项目新建Maven项目 file&gt;New&gt;Project 设置 GroupId、Artifactld、Version ​ GroupId: 组织名，公司网址的反写 + 项目名称 ​ ArtifactId: 项目名-模块名 ​ Version: 项目版本 选择安装位置，点击Finish完成构建 Maven目录结构1234567891011121314src -main -java java源代码文件 -resources 资源库，会自动复制到classes目录里 -webapp web应用的目录。WEB-INF、css、js等 - test -java 单元测试java源代码文件 -resources 测试需要用的资源库target - classes 项目主体输出目录 - test-classes 项目测试输出目录pom.xml maven的pom文件,再此处添加jar依赖LICENSE.txt Project’s licenseREADME.txt Project’s readme 测试在pom.xml中添加Spring依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在/src/main/java下创建Person类 123456public class Person &#123; private String name; private Integer age; // getter、setter 省略 在/src/main/resourse下创建 applicationContext.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt; &lt;constructor-arg value=&quot;yyyy-MM-dd &quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;yuxiang&quot; class=&quot;com.yuxiang.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;雨巷&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 创建程序入口类 123456789public class ApplicationMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person yuxiang = (Person) context.getBean(&quot;yuxiang&quot;); System.out.println(yuxiang); // 运行结果的 Person&#123;name=&#x27;雨巷&#x27;, age=20&#125; &#125;&#125; 项目结构图 eclipse配置Maven","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Maven","slug":"项目构建/Maven","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yuxiangai.cn/tags/Maven/"}]}],"categories":[{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/categories/git/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB搭建网站","slug":"阿里云/PolarDB搭建网站","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/PolarDB%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"},{"name":"SBL负载均衡","slug":"阿里云/SBL负载均衡","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/SBL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"Docker","slug":"阿里云/Docker","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/Docker/"},{"name":"ftp服务","slug":"阿里云/ftp服务","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/ftp%E6%9C%8D%E5%8A%A1/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/categories/MySQL/"},{"name":"MySQL索引","slug":"MySQL/MySQL索引","permalink":"http://yuxiangai.cn/categories/MySQL/MySQL%E7%B4%A2%E5%BC%95/"},{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/categories/redis/"},{"name":"redis使用","slug":"redis/redis使用","permalink":"http://yuxiangai.cn/categories/redis/redis%E4%BD%BF%E7%94%A8/"},{"name":"PXC集群","slug":"MySQL/PXC集群","permalink":"http://yuxiangai.cn/categories/MySQL/PXC%E9%9B%86%E7%BE%A4/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/categories/zookeeper/"},{"name":"zookeeper分布式锁","slug":"zookeeper/zookeeper分布式锁","permalink":"http://yuxiangai.cn/categories/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"项目构建","slug":"项目构建","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Gradle","slug":"项目构建/Gradle","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Gradle/"},{"name":"golang","slug":"golang","permalink":"http://yuxiangai.cn/categories/golang/"},{"name":"gin","slug":"golang/gin","permalink":"http://yuxiangai.cn/categories/golang/gin/"},{"name":"Maven","slug":"项目构建/Maven","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Maven/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/tags/git/"},{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB","slug":"PolarDB","permalink":"http://yuxiangai.cn/tags/PolarDB/"},{"name":"SLB","slug":"SLB","permalink":"http://yuxiangai.cn/tags/SLB/"},{"name":"Docker","slug":"Docker","permalink":"http://yuxiangai.cn/tags/Docker/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://yuxiangai.cn/tags/vsftpd/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/tags/MySQL/"},{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/tags/redis/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/tags/zookeeper/"},{"name":"Gradle","slug":"Gradle","permalink":"http://yuxiangai.cn/tags/Gradle/"},{"name":"Go","slug":"Go","permalink":"http://yuxiangai.cn/tags/Go/"},{"name":"Gin","slug":"Gin","permalink":"http://yuxiangai.cn/tags/Gin/"},{"name":"Maven","slug":"Maven","permalink":"http://yuxiangai.cn/tags/Maven/"}]}