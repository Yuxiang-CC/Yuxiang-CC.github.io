{"meta":{"title":"雨巷的伞","subtitle":"","description":"Java 微服务 cloud vue 雨巷","author":"yuxiang","url":"http://yuxiangai.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"un44fin44","updated":"un44fin44","comments":true,"path":"404.html","permalink":"http://yuxiangai.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"un33fin33","updated":"un33fin33","comments":false,"path":"about/index.html","permalink":"http://yuxiangai.cn/about/index.html","excerpt":"","text":"关于我 雨巷的伞 大三 00后 程序员"},{"title":"所有分类","date":"un33fin33","updated":"un33fin33","comments":false,"path":"categories/index.html","permalink":"http://yuxiangai.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"un33fin33","updated":"un33fin33","comments":false,"path":"tags/index.html","permalink":"http://yuxiangai.cn/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"un11fin11","updated":"un11fin11","comments":false,"path":"friends/index.html","permalink":"http://yuxiangai.cn/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2020/12/06/设计模式之单例模式/","link":"","permalink":"http://yuxiangai.cn/2020/12/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式之单例模式","text":"设计模式之单例模式 介绍","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yuxiangai.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"阿里云vod视频点播","slug":"阿里云vod视频点播","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2020/11/13/阿里云vod视频点播/","link":"","permalink":"http://yuxiangai.cn/2020/11/13/%E9%98%BF%E9%87%8C%E4%BA%91vod%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/","excerpt":"阿里云vod视频点播，视频播放","text":"阿里云vod视频点播，视频播放 视频点播介绍阿里云视频点播（ApsaraVideo for VoD）是集音视频采集、编辑、上传、自动化转码处理、媒体资源管理、高效云剪辑处理、分发加速、视频播放于一体的一站式音视频点播解决方案。 阿里云视频点播整体服务构建在阿里云强大的基础设施服务之上，提供端到端的视频全链路服务，帮助企业和开发者快速搭建安全、弹性、高可定制的视频点播平台和应用。提供Web管理控制台和软件开发工具包（API+SDK，包括视频上传、播放器等）。您可以通过它们使用和管理视频点播服务（视频审核、云剪辑），也可以与您自己的应用和服务集成。 主要业务场景： 音视频网站 无论是初创视频服务企业，还是已拥有海量视频资源，可定制化的点播服务帮助您快速搭建拥有极致观看体验、安全可靠的视频点播应用。 短视频 集音视频拍摄、特效编辑、本地转码、高速上传、自动化云端转码、媒体资源管理、分发加速、播放于一体的完整短视频解决方案。目前已帮助1000+APP快速实现手机短视频功能。 在线教育 提供简单易用、安全可靠的视频点播服务。可通过控制台/API等多种方式上传教学视频，强大的转码能力保证视频可以快速发布，覆盖全网的加速节点保证学生观看的流畅度。防盗链、视频加密等版权保护方案保护教学内容不被窃取。 直播转点播 将直播流同步录制为点播视频，用于回看。并支持媒资管理、媒体处理（转码及内容审核/智能首图等AI处理）、内容制作（云剪辑）、CDN分发加速等一系列操作。 配置解释 转码模板组： 将上传的视频转码为【流畅、标清、高清】等。 视频审核： 审核视频是否有色情暴力等不良画面，可以人工审核和机器审核，审核通过即可播放。 工作流管理： 工作流旨在将这些功能流程化、实例化，用户可提前构建自定义处理流程，并将制定视频按照特定工作流程进行处理，避免用户重复、繁琐的调用接口，提供一站式的媒体处理服务。同时，工作流提供了丰富的条件判断机制，可自定义下一节点条件触发条件，便于灵活组建场景化处理流程。 搭建环境1）、创建Maven项目。 2）、添加pom依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yuxiang&lt;/groupId&gt; &lt;artifactId&gt;aliyun_vod&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;2.15.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;1.4.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20170516&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;sonatype-nexus-staging&lt;/id&gt; &lt;name&gt;Sonatype Nexus Staging&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 注意：其中一个依赖需要我们下载将其安装到本地Maven仓库。 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;1.4.13&lt;/version&gt;&lt;/dependency&gt; 下载地址：服务端上传SDK 将文件解压缩进入lib目录中执行以下命令即可 1mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-java-vod-upload -Dversion=1.4.13 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.13.jar 代码操作基础代码 12345678910111213141516171819202122232425262728293031323334353637383940package com.yuxiang;import com.aliyun.vod.upload.impl.UploadVideoImpl;import com.aliyun.vod.upload.req.UploadStreamRequest;import com.aliyun.vod.upload.resp.UploadStreamResponse;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.vod.model.v20170321.GetPlayInfoRequest;import com.aliyuncs.vod.model.v20170321.GetPlayInfoResponse;import com.aliyuncs.vod.model.v20170321.GetVideoPlayAuthRequest;import com.aliyuncs.vod.model.v20170321.GetVideoPlayAuthResponse;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.util.List;public class AliyunVODMain &#123; public static final String ACCESSKEY_ID = &quot;LTAI4GG4Ag7&quot;; public static final String ACCESSKEY_SECRET = &quot;5dBOGH58kb&quot;; public static final String TEMPLATE_GROUP_ID = &quot;转码模板组ID&quot;; public static final String WORKFLOW_ID = &quot;工作流ID&quot;; public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123; // 点播服务接入区域 String regionId = &quot;cn-shanghai&quot;; DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret); DefaultAcsClient client = new DefaultAcsClient(profile); return client; &#125; public static void main(String[] args) throws Exception &#123;// getPlayInfo();// getVideoPlayAuth();// testUploadVideo();// testRemoveVideo(); &#125;&#125; 视频上传123456789101112131415161718192021222324252627282930/** * 文件流上传 */public static void testUploadVideo() throws FileNotFoundException &#123; String file = &quot;D:/IDEA程序/aliyun_vod/src/main/resources/vod-test.mp4&quot;; String title = &quot;阿里云vod上传测试&quot;; UploadStreamRequest request = new UploadStreamRequest( ACCESSKEY_ID, ACCESSKEY_SECRET, title, &quot;vod-test.mp4&quot;, new FileInputStream(new File(file))); /* 封面图片(可选) */ //request.setCoverURL(&quot;http://cover.sample.com/sample.jpg&quot;); /* 模板组ID(可选) */ //request.setTemplateGroupId(TEMPLATE_GROUP_ID); /* 工作流ID(可选) */ //request.setWorkflowId(WORKFLOW_ID); UploadVideoImpl uploader = new UploadVideoImpl(); UploadStreamResponse response = uploader.uploadStream(request); if (response.isSuccess()) &#123; System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); &#125; else &#123; /* 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 */ System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); System.out.print(&quot;ErrorCode=&quot; + response.getCode() + &quot;\\n&quot;); System.out.print(&quot;ErrorMessage=&quot; + response.getMessage() + &quot;\\n&quot;); &#125;&#125; 获取视频信息12345678910111213141516171819202122/** * 获取视频播放地址 */public static void getPlayInfo() throws Exception &#123; DefaultAcsClient client = initVodClient(ACCESSKEY_ID, ACCESSKEY_SECRET); GetPlayInfoRequest request = new GetPlayInfoRequest(); request.setVideoId(&quot;视频ID&quot;); GetPlayInfoResponse response = client.getAcsResponse(request); try &#123; List&lt;GetPlayInfoResponse.PlayInfo&gt; playInfoList = response.getPlayInfoList(); //播放地址， for (GetPlayInfoResponse.PlayInfo playInfo : playInfoList) &#123; System.out.print(&quot;PlayInfo.PlayURL = &quot; + playInfo.getPlayURL() + &quot;\\n&quot;); &#125; //Base信息 System.out.print(&quot;VideoBase.Title = &quot; + response.getVideoBase().getTitle() + &quot;\\n&quot;); &#125; catch (Exception e) &#123; System.out.print(&quot;ErrorMessage = &quot; + e.getLocalizedMessage()); &#125; System.out.print(&quot;RequestId = &quot; + response.getRequestId() + &quot;\\n&quot;);&#125; 获取视频播放凭证123456789101112131415161718192021/** * 获取视频播放凭证 */public static void getVideoPlayAuth() throws Exception &#123; DefaultAcsClient client = initVodClient(ACCESSKEY_ID, ACCESSKEY_SECRET); GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); request.setVideoId(&quot;238b96b00033486f&quot;); GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse(); try &#123; response = client.getAcsResponse(request); //播放凭证 System.out.print(&quot;PlayAuth = &quot; + response.getPlayAuth() + &quot;\\n&quot;); //VideoMeta信息 System.out.print(&quot;VideoMeta.Title = &quot; + response.getVideoMeta() + &quot;\\n&quot;); &#125; catch (Exception e) &#123; System.out.print(&quot;ErrorMessage = &quot; + e.getLocalizedMessage()); &#125; System.out.print(&quot;RequestId = &quot; + response.getRequestId() + &quot;\\n&quot;);&#125; 删除视频123456789101112131415161718192021/** * 删除视频 */public static void testRemoveVideo() throws Exception &#123; DefaultAcsClient client = initVodClient(ACCESSKEY_ID, ACCESSKEY_SECRET); DeleteVideoResponse response = new DeleteVideoResponse(); try &#123; DeleteVideoRequest request = new DeleteVideoRequest(); //支持传入多个视频ID，多个用逗号分隔【逗号后请勿输入“空格”】 // request.setVideoIds(&quot;videoID1,videoID2&quot;); request.setVideoIds(&quot;95ec2375091a4c4e,238b96b000334&quot;); response = client.getAcsResponse(request); &#125; catch (Exception e) &#123; System.out.print(&quot;ErrorMessage = &quot; + e.getLocalizedMessage()); &#125; System.out.println(response); System.out.print(&quot;RequestId = &quot; + response.getRequestId() + &quot;\\n&quot;);&#125; 。。。。。。 web播放器阿里云Web播放器SDK（Aliplayer SDK）是阿里视频云端到云到端服务的重要一环，除了支持点播和直播的基础播放功能外，深度融合视频云业务，如支持视频的加密播放、清晰度切换、直播时移等业务场景，为用户提供简单、快速、安全、稳定的视频播放服务。 点击查看功能展示。","categories":[{"name":"业务功能","slug":"业务功能","permalink":"http://yuxiangai.cn/categories/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"}],"tags":[]},{"title":"短信验证码","slug":"短信验证码发送","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2020/11/10/短信验证码发送/","link":"","permalink":"http://yuxiangai.cn/2020/11/10/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%91%E9%80%81/","excerpt":"使用阿里云短信服务发送验证码","text":"使用阿里云短信服务发送验证码 阿里云短信服务短信服务（Short Message Service）是指通过调用短信发送API，将指定短信内容发送给指定手机用户。用户收到的短信来自106开头的号码，短信的内容多用于企业向用户传递验证码、系统通知、会员服务等信息。 前置准备 阿里云账户实名认证。 开通短信服务。 创建签名。 创建模板。 签名与模板创建可看阿里云短信服务文档。 编码实现Api文档地址。 1）、创建Maven项目。 2）、导入依赖。 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yuxiang&lt;/groupId&gt; &lt;artifactId&gt;aliyunsms&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 发送验证码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.yuxiang;import com.aliyuncs.CommonRequest;import com.aliyuncs.CommonResponse;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.http.MethodType;import com.aliyuncs.profile.DefaultProfile;import com.google.gson.Gson;import java.util.*;/** * @Author: yuxiang * @Date: 2020/11/10 19:58 */public class AliyunSMSMain &#123; public final static String ACCESS_KEY = &quot;LTAI4GG4Ag7aaaaaaaaaa&quot;; public final static String ACCESS_SECRET = &quot;5dBOGH58kbp8aaaaaaaaaaaaaaa&quot;; public final static String PHONE_NUMBER = &quot;18312341234&quot;; public final static String SIGN_NAME = &quot;签名名称&quot;; public final static String TEMPLATE_CODE = &quot;模版CODE&quot;; public static void main(String[] args) throws ClientException &#123; DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, ACCESS_KEY, ACCESS_SECRET); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); // 配置 request.setSysMethod(MethodType.POST); request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setSysVersion(&quot;2017-05-25&quot;); request.setSysAction(&quot;SendSms&quot;); request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;); // 设置信息 request.putQueryParameter(&quot;PhoneNumbers&quot;, PHONE_NUMBER); request.putQueryParameter(&quot;SignName&quot;, SIGN_NAME); request.putQueryParameter(&quot;TemplateCode&quot;, TEMPLATE_CODE); // 生成随机验证码 String code = String.valueOf(new Random().nextInt(899999) + 100000); request.putQueryParameter(&quot;TemplateParam&quot;, &quot;&#123;\\&quot;code\\&quot;:\\&quot;&quot; + code + &quot;\\&quot;&#125;&quot;); CommonResponse response = client.getCommonResponse(request); // 解析响应结果 String data = response.getData(); Gson gson = new Gson(); HashMap hashMap = gson.fromJson(data, HashMap.class); Set set = hashMap.entrySet(); Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = (Map.Entry&lt;String, Object&gt;) iterator.next(); System.out.println(&quot;key:&quot; + entry.getKey() + &quot; \\t value:&quot; + entry.getValue()); &#125; Object resultCode = hashMap.get(&quot;Code&quot;); Object resultMessage = hashMap.get(&quot;Message&quot;); if (&quot;isv.DAY_LIMIT_CONTROL&quot;.equals(resultCode)) &#123; System.err.println(&quot;短信发送失败,code:&quot; + resultCode + &quot;,message:&quot; + resultMessage); &#125; if (!&quot;OK&quot;.equals(resultCode)) &#123; System.err.println(&quot;短信发送失败,code:&quot; + resultCode + &quot;,message:&quot; + resultMessage); &#125; System.out.println(&quot;短信发送成功！&quot;); /** 结果如下： * key:Message value:OK * key:RequestId value:D787642C-F645-4185-B7DF-CC4B2CAE54A1 * key:BizId value:287621605011850452^0 * key:Code value:OK * 短信发送成功！ */ &#125;&#125; 查询短信发送详情1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.yuxiang;import com.aliyuncs.CommonRequest;import com.aliyuncs.CommonResponse;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.exceptions.ServerException;import com.aliyuncs.http.MethodType;import com.aliyuncs.profile.DefaultProfile;import com.google.gson.Gson;import java.util.*;/** * @Author: yuxiang * @Date: 2020/11/10 19:58 */public class AliyunSMSMain &#123; public final static String ACCESS_KEY = &quot;LTAI4GG4Ag7Yaaaaa&quot;; public final static String ACCESS_SECRET = &quot;5dBOGH58kbaaaaaaa&quot;; public final static String PHONE_NUMBER = &quot;18312341234&quot;; public static void main(String[] args) throws ClientException &#123; DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, ACCESS_KEY, ACCESS_SECRET); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setSysVersion(&quot;2017-05-25&quot;); request.setSysAction(&quot;QuerySendDetails&quot;); request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;); request.putQueryParameter(&quot;PhoneNumber&quot;, PHONE_NUMBER); request.putQueryParameter(&quot;SendDate&quot;, &quot;20201110&quot;); request.putQueryParameter(&quot;PageSize&quot;, &quot;10&quot;); request.putQueryParameter(&quot;CurrentPage&quot;, &quot;1&quot;); try &#123; CommonResponse response = client.getCommonResponse(request); Gson gson = new Gson(); HashMap hashMap = gson.fromJson(response.getData(), HashMap.class); Iterator iterator = hashMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = (Map.Entry&lt;String, Object&gt;) iterator.next(); System.out.println(&quot;key:&quot; + entry.getKey() + &quot; \\t value:&quot; + entry.getValue()); &#125; &#125; catch (ServerException e) &#123; e.printStackTrace(); &#125; catch (ClientException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"业务功能","slug":"业务功能","permalink":"http://yuxiangai.cn/categories/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"}],"tags":[]},{"title":"Java发送邮件","slug":"Java发送邮件","date":"un11fin11","updated":"un22fin22","comments":true,"path":"2020/11/09/Java发送邮件/","link":"","permalink":"http://yuxiangai.cn/2020/11/09/Java%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","excerpt":"使用SpringBoot搭建，发送邮件。","text":"使用SpringBoot搭建，发送邮件。 创建项目 打开IDEA。 选择File-&gt;New-&gt;Project，使用Spring Initializr创建SpringBoot项目。 设置gav。 点击Next-&gt;Finish，创建项目完成。 添加依赖123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yuxiang&lt;/groupId&gt; &lt;artifactId&gt;mailsend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mailsend&lt;/name&gt; &lt;description&gt;使用java发送邮件&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 获取授权密码163邮箱163邮箱 点击新增授权密码，发送短信添加授权密码。 注意：授权密码只会显示一次，请保存好。 QQ邮箱QQ邮箱 点击开启，发送短信获取授权密码。 发送邮件Spring send mail 文档。 发送纯文字邮件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.yuxiang.mailsend;import org.springframework.mail.MailException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import java.util.Date;public class MailSendApplication &#123; public static void main(String[] args) throws Exception&#123; JavaMailSenderImpl javaMailSender = new JavaMailSenderImpl(); // 邮箱授权密码 javaMailSender.setPassword(&quot;AAAAAAAAAAA&quot;); // 163邮箱：smtp.163.com // QQ邮箱： smtp.qq.com javaMailSender.setHost(&quot;smtp.163.com&quot;); // 发送者邮箱账号 javaMailSender.setUsername(&quot;ren666665@163.com&quot;); SimpleMailMessage msg = new SimpleMailMessage(); /** * 发送者邮箱账号和昵称 * 当为，雨巷&lt;ren666665@163.com&gt;时，邮件发送昵称为&lt;雨巷&gt; * 当为，ren666665@163.com时，邮件发送昵称为&lt;ren666665&gt; */ msg.setFrom(&quot;雨巷&lt;ren666665@163.com&gt;&quot;); msg.setSentDate(new Date()); // 邮件主题 msg.setSubject(&quot;订单通知&quot;); // 接收者邮箱账号 msg.setTo(&quot;610232665@qq.com&quot;); // 邮件内容 msg.setText( &quot;Dear: 你好！&quot; + &quot;&lt;a href=\\&quot;www.yuxiangai.cn\\&quot;&gt;点击查看&lt;/a&gt;&quot; + &quot;, thank you for placing order. Your order number is [4567]&quot; + &quot;, from: XXX&quot;); try&#123; javaMailSender.send(msg); &#125; catch (MailException ex) &#123; // simply log it and go on... System.err.println(ex.getMessage()); &#125; System.out.println(&quot;发送邮件成功！&quot;); &#125;&#125; 发送带附件和HTML解析邮件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yuxiang.mailsend;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.MailException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMessageHelper;import javax.mail.internet.MimeMessage;import java.io.File;import java.util.Date;public class MailSendApplication &#123; public static void main(String[] args) throws Exception&#123; JavaMailSenderImpl javaMailSender = new JavaMailSenderImpl(); javaMailSender.setPassword(&quot;AAAAAAAAAAAAAAA&quot;); javaMailSender.setHost(&quot;smtp.163.com&quot;); javaMailSender.setUsername(&quot;ren666665@163.com&quot;); MimeMessage msg = javaMailSender.createMimeMessage(); // 使用true标志表示您需要一个多部分消息，UTF-8设置邮件消息编码 MimeMessageHelper helper = new MimeMessageHelper(msg, true, &quot;UTF-8&quot;); /** * 发送者邮箱账号和昵称 * 当为，雨巷&lt;ren666665@163.com&gt;时，邮件发送昵称为&lt;雨巷&gt; * 当为，ren666665@163.com时，邮件发送昵称为&lt;ren666665&gt; */ helper.setFrom(&quot;雨巷&lt;ren666665@163.com&gt;&quot;); helper.setTo(&quot;610232665@qq.com&quot;); helper.setSubject(&quot;考试人员名单&quot;); // 使用true标志解析为HTML helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;h2&gt;人员名单&lt;/h2&gt;&lt;strong&gt;strong&lt;/strong&gt;&lt;br/&gt; &quot; + &quot;&lt;a href=\\&quot;http://www.yuxiangai.cn\\&quot;&gt;查看网站&lt;/a&gt; &lt;br/&gt;&quot; + &quot;&lt;ul&gt;&lt;li&gt;lu&lt;/li&gt;&lt;li&gt;任&lt;/li&gt;&lt;li&gt;wang&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&quot;, true); // 添加附件 FileSystemResource file = new FileSystemResource(new File(&quot;d:/yuxiang.png&quot;)); helper.addAttachment(&quot;人员名单照片&quot;, file); try&#123; javaMailSender.send(msg); &#125; catch (MailException ex) &#123; // simply log it and go on... System.err.println(ex.getMessage()); &#125; System.out.println(&quot;发送邮件成功！&quot;); &#125;&#125;","categories":[{"name":"业务功能","slug":"业务功能","permalink":"http://yuxiangai.cn/categories/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"}],"tags":[]},{"title":"支付宝支付","slug":"支付宝支付","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2020/11/06/支付宝支付/","link":"","permalink":"http://yuxiangai.cn/2020/11/06/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/","excerpt":"沙箱环境对接支付宝支付","text":"沙箱环境对接支付宝支付 支付宝开发平台设置注册登录账号 支付宝开发平台登录账号。 单击进入管理中心。在控制台下选择研发服务。 查看沙箱应用的信息配置。 说明：我这里的密匙已经设置过了，如果你是第一次进入则显示的会不一样。 注意：记得此处APPID、支付宝网关后续需要用到。 生成密钥 下载支付宝开发平台开发助手。 利用支付宝开发平台开发助手生成私钥和公钥。 配置密钥 将公钥添加到沙箱应用–&gt;信息配置–&gt;RSA2(SHA256)密钥。 添加自己的公钥完成之后，会得到支付宝公钥，稍后会用到。 下载沙箱版支付宝，用于测试支付操作。 natapp内网穿透是什么建议自行百度。 注册natapp账号。 进行实名认证，实名认证之后可开通免费隧道。 开通免费隧道。 配置隧道信息。 下载客户端。 建立连接，记录分配域名。 复制隧道的authtoken，进入客户端下载解压缩的目录，执行以下命令： 1natapp --authtoken=token值 启动成功。 此时访问提供的http://xxxxx.natappfree.cc域名即可访问到本地在9999端口暴露的服务。 注意：请记录提供的域名。 编码实现创建项目 创建Maven-webapp项目。 向pom.xml添加依赖。 12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;relativePath&gt;&lt;/relativePath&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-sdk-java --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.10.170.ALL&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 代码index.jsp代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;支付宝网站支付&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, ol &#123; list-style: none; &#125; body &#123; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Lucida Grande&quot;, sans-serif; &#125; .tab-head &#123; margin-left: 120px; margin-bottom: 10px; &#125; .tab-content &#123; clear: left; display: none; &#125; h2 &#123; border-bottom: solid #02aaf1 2px; width: 200px; height: 25px; margin: 0; float: left; text-align: center; font-size: 16px; &#125; .selected &#123; color: #FFFFFF; background-color: #02aaf1; &#125; .show &#123; clear: left; display: block; &#125; .hidden &#123; display: none; &#125; .new-btn-login-sp &#123; padding: 1px; display: inline-block; width: 75%; &#125; .new-btn-login &#123; background-color: #02aaf1; color: #FFFFFF; font-weight: bold; border: none; width: 100%; height: 30px; border-radius: 5px; font-size: 16px; &#125; #main &#123; width: 100%; margin: 0 auto; font-size: 14px; &#125; .red-star &#123; color: #f00; width: 10px; display: inline-block; &#125; .null-star &#123; color: #fff; &#125; .content &#123; margin-top: 5px; &#125; .content dt &#123; width: 100px; display: inline-block; float: left; margin-left: 20px; color: #666; font-size: 13px; margin-top: 8px; &#125; .content dd &#123; margin-left: 120px; margin-bottom: 5px; &#125; .content dd input &#123; width: 85%; height: 28px; border: 0; -webkit-border-radius: 0; -webkit-appearance: none; &#125; #foot &#123; margin-top: 10px; position: absolute; bottom: 15px; width: 100%; &#125; .foot-ul &#123; width: 100%; &#125; .foot-ul li &#123; width: 100%; text-align: center; color: #666; &#125; .note-help &#123; color: #999999; font-size: 12px; line-height: 130%; margin-top: 5px; width: 100%; display: block; &#125; #btn-dd &#123; margin: 20px; text-align: center; &#125; .foot-ul &#123; width: 100%; &#125; .one_line &#123; display: block; height: 1px; border: 0; border-top: 1px solid #eeeeee; width: 100%; margin-left: 20px; &#125; .am-header &#123; display: -webkit-box; display: -ms-flexbox; display: -moz-box; width: 100%; position: relative; padding: 7px 0; -webkit-box-sizing: border-box; -ms-box-sizing: border-box; box-sizing: border-box; background: #1D222D; height: 50px; text-align: center; -webkit-box-pack: center; -ms-flex-pack: center; box-pack: center; -webkit-box-align: center; -ms-flex-align: center; box-align: center; &#125; .am-header h1 &#123; -webkit-box-flex: 1; -ms-flex: 1; box-flex: 1; line-height: 18px; text-align: center; font-size: 18px; font-weight: 300; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body text=#000000 bgColor=&quot;#ffffff&quot; leftMargin=0 topMargin=4&gt;&lt;header class=&quot;am-header&quot;&gt; &lt;h1&gt;支付宝体验入口页&lt;/h1&gt;&lt;/header&gt;&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;tabhead&quot; class=&quot;tab-head&quot;&gt; &lt;h2 id=&quot;tab1&quot; class=&quot;selected&quot; name=&quot;tab&quot;&gt;付 款&lt;/h2&gt; &lt;/div&gt; &lt;form name=&quot;alipayment&quot; action=&quot;/pay&quot; method=&quot;post&quot; target=&quot;_blank&quot;&gt; &lt;div id=&quot;body1&quot; class=&quot;show&quot; name=&quot;divcontent&quot;&gt; &lt;dl class=&quot;content&quot;&gt; &lt;dt&gt;商户订单号 ：&lt;/dt&gt; &lt;dd&gt; &lt;input id=&quot;WIDout_trade_no&quot; name=&quot;WIDout_trade_no&quot; /&gt; &lt;/dd&gt; &lt;hr class=&quot;one_line&quot;&gt; &lt;dt&gt;订单名称 ：&lt;/dt&gt; &lt;dd&gt; &lt;input id=&quot;WIDsubject&quot; name=&quot;WIDsubject&quot; /&gt; &lt;/dd&gt; &lt;hr class=&quot;one_line&quot;&gt; &lt;dt&gt;付款金额 ：&lt;/dt&gt; &lt;dd&gt; &lt;input id=&quot;WIDtotal_amount&quot; name=&quot;WIDtotal_amount&quot; /&gt; &lt;/dd&gt; &lt;hr class=&quot;one_line&quot;&gt; &lt;dt&gt;商品描述：&lt;/dt&gt; &lt;dd&gt; &lt;input id=&quot;WIDbody&quot; name=&quot;WIDbody&quot; /&gt; &lt;/dd&gt; &lt;hr class=&quot;one_line&quot;&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd id=&quot;btn-dd&quot;&gt; &lt;span class=&quot;new-btn-login-sp&quot;&gt; &lt;button class=&quot;new-btn-login&quot; type=&quot;submit&quot; style=&quot;text-align: center;&quot;&gt;付 款&lt;/button&gt; &lt;/span&gt; &lt;span class=&quot;note-help&quot;&gt;如果您点击“付款”按钮，即表示您同意该次的执行操作。&lt;/span&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/form&gt; &lt;div id=&quot;foot&quot;&gt; &lt;ul class=&quot;foot-ul&quot;&gt; &lt;li&gt;版权所有 2015-2018&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script language=&quot;javascript&quot;&gt; function GetDateNow() &#123; var vNow = new Date(); var sNow = &quot;&quot;; sNow += String(vNow.getFullYear()); sNow += String(vNow.getMonth() + 1); sNow += String(vNow.getDate()); sNow += String(vNow.getHours()); sNow += String(vNow.getMinutes()); sNow += String(vNow.getSeconds()); sNow += String(vNow.getMilliseconds()); document.getElementById(&quot;WIDout_trade_no&quot;).value = sNow; document.getElementById(&quot;WIDsubject&quot;).value = &quot;商品名称&quot;; document.getElementById(&quot;WIDtotal_amount&quot;).value = &quot;0.01&quot;; &#125; GetDateNow();&lt;/script&gt;&lt;/html&gt; application.properties配置文件。 12345678# 页面默认前缀目录spring.mvc.view.prefix=/# 响应页面默认后缀spring.mvc.view.suffix=.jsp# 访问对口server.port=9999# 设置访问的项目路径server.servlet.context-path=/ 创建com.yuxiang.AlipayDemoMain类。 123456789101112131415package com.yuxiang;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @Author: yuxiang * @Date: 2020/11/5 21:02 */@SpringBootApplication()public class AliPayDemoMain &#123; public static void main(String[] args) &#123; SpringApplication.run(AliPayDemoMain.class, args); &#125;&#125; 创建com.yuxiang.util.AlipayUtils类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.yuxiang.util;/** * @Author: yuxiang * @Date: 2020/11/5 20:35 */public class AlipayUtils &#123; /** * 应用ID，您的APPID，收款账号既是您的APPID对应的支付宝账号 */ public static String app_id = &quot;2016&quot;; /** * 商户私钥 */ public static String merchant_private_key = &quot;开发者工具生成的私钥&quot;; /** * 支付宝公钥 */ public static String alipay_public_key = &quot;支付宝公钥&quot;; /** * 服务器异步通知页面路径 * 需http://格式的完整路径，不能加?id=1这类自定义参数，必须外网可以访问 */ public static String notify_url = &quot;http://&lt;natapp提供的域名&gt;/getnogify&quot;; /** * 页面跳转同步通知页面路径 * 需http://格式的完整路径，不能加?id=1这类自定义参数，必须外网可以访问 */ public static String return_url = &quot;http://&lt;natapp提供的域名&gt;/getreturn&quot;; /** * 签名方式 */ public static String sign_type = &quot;RSA2&quot;; /** * 字符编码格式 */ public static String charset = &quot;UTF-8&quot;; /** * 支付宝网关，注意使用的是沙箱的支付宝网关，与正常网关的区别是多了dev */ public static String gatewayUrl = &quot;https://openapi.alipaydev.com/gateway.do&quot;;&#125; 创建com.yuxiang.config.AliPayConfiguration类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.yuxiang.config;import com.alipay.api.AlipayClient;import com.alipay.api.DefaultAlipayClient;import com.alipay.api.request.AlipayTradePagePayRequest;import com.yuxiang.util.AlipayUtils;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @Author: yuxiang * @Date: 2020/11/5 21:10 */@Configurationpublic class AliPayConfiguration &#123; /** * 创建支付宝客户端对象 * @return */ @Bean(&quot;alipayClient&quot;) public AlipayClient alipayClient() &#123; DefaultAlipayClient client = new DefaultAlipayClient( AlipayUtils.gatewayUrl, AlipayUtils.app_id, AlipayUtils.merchant_private_key, &quot;json&quot;, AlipayUtils.charset, AlipayUtils.alipay_public_key, AlipayUtils.sign_type); return client; &#125; /** * 支付信息的配置 * @return */ @Bean public AlipayTradePagePayRequest alipayTradePagePayRequest() &#123; return new AlipayTradePagePayRequest(); &#125;&#125; 创建com.yuxiang.controller.NotifyController类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.yuxiang.controller;import com.alipay.api.internal.util.AlipaySignature;import com.yuxiang.util.AlipayUtils;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * @Author: yuxiang * @Date: 2020/11/5 21:49 */@Controllerpublic class NotifyController &#123; @RequestMapping(&quot;/getnotify&quot;) public void notifyUrl(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; // 获取支付宝POST过来反馈信息 Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;(); Map&lt;String,String[]&gt; requestParams = request.getParameterMap(); Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); while(iter.hasNext())&#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; &#125; //乱码解决，这段代码在出现乱码时使用 //valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); params.put(name, valueStr); &#125; //调用SDK验证签名 boolean signVerified = AlipaySignature.rsaCheckV1(params, AlipayUtils.alipay_public_key, AlipayUtils.charset, AlipayUtils.sign_type); //——请在这里编写您的程序（以下代码仅作参考）—— /* 实际验证过程建议商户务必添加以下校验： 1、需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号， 2、判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额）， 3、校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方 （有的时候，一个商户可能有多个seller_id/seller_email） 4、验证app_id是否为该商户本身。 */ response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); if(signVerified) &#123; //验证成功 //商户订单号 String out_trade_no =request.getParameter(&quot;out_trade_no&quot;); //支付宝交易号 String trade_no = request.getParameter(&quot;trade_no&quot;); //交易状态 String trade_status = request.getParameter(&quot;trade_status&quot;); if(trade_status.equals(&quot;TRADE_FINISHED&quot;))&#123; //判断该笔订单是否在商户网站中已经做过处理 //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序 //如果有做过处理，不执行商户的业务程序 //注意： //退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知 &#125;else if (trade_status.equals(&quot;TRADE_SUCCESS&quot;))&#123; //判断该笔订单是否在商户网站中已经做过处理 //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序 //如果有做过处理，不执行商户的业务程序 //注意： //付款完成后，支付宝系统发送该交易状态通知 &#125; out.println(&quot;success&quot;); &#125;else &#123;//验证失败 out.println(&quot;fail&quot;); //调试用，写文本函数记录程序运行情况是否正常 //String sWord = AlipaySignature.getSignCheckContentV1(params); //AlipayConfig.logResult(sWord); &#125; &#125;&#125; 创建com.yuxiang.controller.ReturnController类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.yuxiang.controller;import com.alipay.api.internal.util.AlipaySignature;import com.yuxiang.util.AlipayUtils;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.function.BiConsumer;/** * @Author: yuxiang * @Date: 2020/11/6 9:39 */@Controllerpublic class ReturnController &#123; @RequestMapping(&quot;/getreturn&quot;) public void returnUrl(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; //获取支付宝GET过来反馈信息 Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;(); Map&lt;String,String[]&gt; requestParams = request.getParameterMap(); Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); while(iter.hasNext())&#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; &#125; //乱码解决，这段代码在出现乱码时使用 //valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); params.put(name, valueStr); &#125; params.forEach((k,v) -&gt; &#123; System.out.println(&quot;key:&quot; + k + &quot;value:&quot; + v); &#125;); //RSA2验证 boolean signVerified = AlipaySignature.rsaCheckV1(params, AlipayUtils.alipay_public_key, AlipayUtils.charset, AlipayUtils.sign_type); response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); //——请在这里编写您的程序（以下代码仅作参考）—— if(signVerified) &#123; out.println(&quot;验签成功&quot;); //商户订单号 String out_trade_no = request.getParameter(&quot;out_trade_no&quot;); //支付宝交易号 String trade_no = request.getParameter(&quot;trade_no&quot;); //付款金额 String total_amount = request.getParameter(&quot;total_amount&quot;); out.println( &quot;trade_no:&quot;+trade_no+&quot;&lt;br/&gt;out_trade_no:&quot;+out_trade_no+ &quot;&lt;br/&gt;total_amount:&quot;+total_amount); &#125;else &#123; out.println(&quot;验签失败&quot;); //商户订单号 String out_trade_no = request.getParameter(&quot;out_trade_no&quot;); //支付宝交易号 String trade_no = request.getParameter(&quot;trade_no&quot;); //付款金额 String total_amount = request.getParameter(&quot;total_amount&quot;); out.println( &quot;trade_no:&quot;+trade_no+&quot;&lt;br/&gt;out_trade_no:&quot;+out_trade_no+ &quot;&lt;br/&gt;total_amount:&quot;+total_amount); &#125; &#125;&#125; 创建com.yuxiang.controller.PayController类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.yuxiang.controller;import com.alipay.api.AlipayApiException;import com.alipay.api.AlipayClient;import com.alipay.api.DefaultAlipayClient;import com.alipay.api.request.AlipayTradePagePayRequest;import com.alipay.api.request.AlipayTradePayRequest;import com.alipay.api.response.AlipayTradePagePayResponse;import com.alipay.api.response.AlipayTradePayResponse;import com.yuxiang.util.AlipayUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Author: yuxiang * @Date: 2020/11/5 21:18 */@Controllerpublic class PayController &#123; @Autowired private AlipayClient alipayClient; @Autowired private AlipayTradePagePayRequest alipayTradePagePayRequest; /** * 接受表单传递过来的数据 * @param WIDout_trade_no 订单号 * @param WIDsubject 名称 * @param WIDtotal_amount 金额 * @param WIDbody 描述 */ @RequestMapping(&quot;/pay&quot;) public void pay(String WIDout_trade_no, String WIDsubject, String WIDtotal_amount, String WIDbody, HttpServletResponse response) throws AlipayApiException, IOException &#123; // 1.设置支付宝服务器返回访问地址 alipayTradePagePayRequest.setNotifyUrl(AlipayUtils.notify_url); alipayTradePagePayRequest.setReturnUrl(AlipayUtils.return_url); // 2.设置请求参数（传递给支付宝服务器的数据） alipayTradePagePayRequest.setBizContent( &quot;&#123;\\&quot;out_trade_no\\&quot;:\\&quot;&quot;+ WIDout_trade_no +&quot;\\&quot;,&quot; + &quot;\\&quot;total_amount\\&quot;:\\&quot;&quot;+ WIDtotal_amount +&quot;\\&quot;,&quot; + &quot;\\&quot;subject\\&quot;:\\&quot;&quot;+ WIDsubject +&quot;\\&quot;,&quot; + &quot;\\&quot;body\\&quot;:\\&quot;&quot;+ WIDbody +&quot;\\&quot;,&quot; + &quot;\\&quot;product_code\\&quot;:\\&quot;FAST_INSTANT_TRADE_PAY\\&quot;&#125;&quot;); // 3.发送请求 AlipayTradePagePayResponse result = alipayClient.pageExecute(alipayTradePagePayRequest, &quot;get&quot;); if (result.isSuccess()) &#123; System.out.println(&quot;成功&quot;); &#125; String body = result.getBody(); System.out.println(body); PrintWriter writer = response.getWriter(); writer.write(body); writer.close(); &#125;&#125; 测试启动后台服务。 访问域名测试。","categories":[{"name":"业务功能","slug":"业务功能","permalink":"http://yuxiangai.cn/categories/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"}],"tags":[]},{"title":"Face++人脸识别登录","slug":"人脸识别登录","date":"un33fin33","updated":"un55fin55","comments":true,"path":"2020/11/04/人脸识别登录/","link":"","permalink":"http://yuxiangai.cn/2020/11/04/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%99%BB%E5%BD%95/","excerpt":"旷视Face++实现人脸识别登录","text":"旷视Face++实现人脸识别登录 旷视旷视是全球领先的人工智能产品和解决方案公司。 Face++便是旗下的一款产品。我们可以注册账号，免费试用人脸识别。 1）、首先注册登录 2）、记录自动生成的API Key，API Secret。 名词解释人脸人脸（Face）在人脸识别技术中特指图像中发现的人脸，当对一张图片进行人脸检测时，会将检测到的人脸记录下来，包括人脸在图片中的位置，用一个系统标识face_token来表示。注意：对同一张图片进行多次人脸检测，对同一个人脸会得到不同的face_token。 人脸集合人脸集合（FaceSet）是用来存储检测到人脸的存储对象。一个FaceSet内face_token是不重复的。 人脸比对/人脸搜索计算机检测到图片中一个人脸之后，通过人脸判断人身份的过程被称为人脸比对/人脸搜索。 人脸比对指采集新的人脸，与一个已知身份用户的人脸进行比对，判断新的人脸是否属于该已知身份用户。人脸比对需要调用Compare API。 人脸搜索是指采集用户新的人脸，在多个已知身份用户的人脸集合中进行搜索，找出新的人脸属于哪一个已知身份用户。人脸搜索需要调用Search API。 实现项目文件结构 需添加一个fastjsonjar包。 前端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;用户管理&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0&quot;/&gt; &lt;!-- 此处可用百度cdn --&gt; &lt;!-- &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt; --&gt; &lt;script src=&quot;assets/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body class=&quot;no-skin&quot;&gt;&lt;div class=&quot;main-container ace-save-state&quot; id=&quot;main-container&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;div class=&quot;main-content-inner&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;div style=&quot;padding: 10px;&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;button class=&quot;btn btn-sm btn-default&quot; onclick=&quot;openMedia()&quot;&gt;开启摄像头&lt;/button&gt; &lt;button class=&quot;btn btn-sm btn-default&quot; onclick=&quot;closeMedia()&quot;&gt;关闭摄像头&lt;/button&gt; &lt;button class=&quot;btn btn-sm btn-default&quot; onclick=&quot;takePhoto(&#x27;login&#x27;)&quot;&gt;登录&lt;/button&gt; &lt;button class=&quot;btn btn-sm btn-default&quot; onclick=&quot;takePhoto(&#x27;register&#x27;)&quot;&gt;注册&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;video id=&quot;video&quot; width=&quot;500px&quot; height=&quot;500px&quot; autoplay=&quot;autoplay&quot;&gt;&lt;/video&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;500px&quot; height=&quot;500px&quot; style=&quot;display: none&quot;&gt;&lt;/canvas&gt; &lt;/td&gt; &lt;td&gt; &lt;img id=&quot;imgTag&quot; src=&quot;&quot; alt=&quot;...&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.page-content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.main-content --&gt;&lt;/div&gt;&lt;!-- /.main-container --&gt;&lt;script&gt; let mediaStreamTrack=null; // 视频对象(全局) let video ; // 开启摄像头 function openMedia() &#123; // 定义属性 let constraints = &#123; video: &#123; width: 500, height: 500 &#125;, audio: false &#125;; //获得video video = document.getElementById(&#x27;video&#x27;); let promise = navigator.mediaDevices.getUserMedia(constraints); promise.then((mediaStream) =&gt; &#123; console.log(&quot;mediaStream: &quot;,mediaStream) mediaStreamTrack=mediaStream.getVideoTracks() video.srcObject = mediaStream; video.play(); &#125;); &#125; // 拍照 function takePhoto(str) &#123; //获得Canvas对象 let video = document.getElementById(&#x27;video&#x27;); let canvas = document.getElementById(&#x27;canvas&#x27;); let ctx = canvas.getContext(&#x27;2d&#x27;); ctx.drawImage(video, 0, 0, 500, 500); // toDataURL --- 可传入&#x27;image/png&#x27;---默认, &#x27;image/jpeg&#x27; let img = document.getElementById(&#x27;canvas&#x27;).toDataURL(); // 这里的img就是得到的图片 console.log(&#x27;img-----&#x27;, img); document.getElementById(&#x27;imgTag&#x27;).src=img; //上传 var flagStr=&quot;登录&quot;; if(str==&quot;register&quot;)&#123; flagStr=&quot;注册&quot;; &#125; // 发送请求 $.ajax(&#123; url:&quot;faceController&quot;, type:&quot;POST&quot;, data:&#123;&quot;imgData&quot;:img,&quot;type&quot;:str&#125;, dataType: &quot;json&quot;, success:function(data)&#123; var flag = data.success; if (flag) &#123; alert(flagStr+&quot;成功&quot;); &#125; else &#123; alert(flagStr+&quot;失败!&quot;); &#125; &#125; ,error:function()&#123; alert(&quot;服务器内部错误！&quot;+flagStr+&quot;失败&quot;) &#125; &#125;); &#125; // 关闭摄像头 function closeMedia() &#123; let stream = document.getElementById(&#x27;video&#x27;).srcObject; console.log(stream) let tracks = stream.getTracks(); tracks.forEach(function(track) &#123; track.stop(); &#125;); document.getElementById(&#x27;video&#x27;).srcObject = null; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端1）、创建api.properties。 参数名 类型 参数说明 api_key String 调用此 API 的 API Key api_secret String 调用此 API 的 API Secret display_name String 人脸集合的名字，最长256个字符，不能包括字符^@,&amp;=*’” outer_id String 账号下全局唯一的 FaceSet 自定义标识，可以用来管理 FaceSet 对象。最长255个字符，不能包括字符^@,&amp;=*’” 1234API_KEY=qkHAF_oRcc_XXXXXXXXXXXXXXXXXXXAPI_SECRET=ywon7MFsXXXXXXXXXXXXXXXXXXXDISPLAY_NAME=此处随意名称OUTER_ID=此处随意名称 2）、创建HTTPUtil.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.yuxiang.facelogin.util;import java.io.ByteArrayOutputStream;import java.io.DataOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLEncoder;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Properties;import java.util.Random;import javax.net.ssl.SSLException;public class HTTPUtil &#123; private final static int CONNECT_TIME_OUT = 30000; private final static int READ_OUT_TIME = 50000; private static String boundaryString = getBoundary(); public static HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); static &#123; Properties pro=new Properties(); InputStream in=FaceUtil.class.getResourceAsStream(&quot;/api.properties&quot;); try &#123; pro.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;配置文件加载错误!&quot;); &#125; map.put(&quot;api_key&quot;, pro.getProperty(&quot;API_KEY&quot;)); map.put(&quot;api_secret&quot;, pro.getProperty(&quot;API_SECRET&quot;)); map.put(&quot;display_name&quot;, pro.getProperty(&quot;DISPLAY_NAME&quot;)); map.put(&quot;outer_id&quot;, pro.getProperty(&quot;OUTER_ID&quot;)); &#125; public static byte[] post(String url, HashMap&lt;String, String&gt; map, HashMap&lt;String, byte[]&gt; fileMap) throws Exception &#123; HttpURLConnection conne; URL url1 = new URL(url); conne = (HttpURLConnection) url1.openConnection(); conne.setDoOutput(true); conne.setUseCaches(false); conne.setRequestMethod(&quot;POST&quot;); conne.setConnectTimeout(CONNECT_TIME_OUT); conne.setReadTimeout(READ_OUT_TIME); conne.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conne.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + boundaryString); conne.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conne.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible;MSIE 6.0;Windows NT 5.1;SV1)&quot;); DataOutputStream obos = new DataOutputStream(conne.getOutputStream()); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = (Map.Entry) iter.next(); String key = entry.getKey(); String value = entry.getValue(); obos.writeBytes(&quot;--&quot; + boundaryString + &quot;\\r\\n&quot;); obos.writeBytes(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + key + &quot;\\&quot;\\r\\n&quot;); obos.writeBytes(&quot;\\r\\n&quot;); obos.writeBytes(value + &quot;\\r\\n&quot;); &#125; if (fileMap != null &amp;&amp; fileMap.size() &gt; 0) &#123; Iterator fileIter = fileMap.entrySet().iterator(); while (fileIter.hasNext()) &#123; Map.Entry&lt;String, byte[]&gt; fileEntry = (Map.Entry&lt;String, byte[]&gt;) fileIter.next(); obos.writeBytes(&quot;--&quot; + boundaryString + &quot;\\r\\n&quot;); obos.writeBytes(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + fileEntry.getKey() + &quot;\\&quot;; filename=\\&quot;&quot; + encode(&quot; &quot;) + &quot;\\&quot;\\r\\n&quot;); obos.writeBytes(&quot;\\r\\n&quot;); obos.write(fileEntry.getValue()); obos.writeBytes(&quot;\\r\\n&quot;); &#125; &#125; obos.writeBytes(&quot;--&quot; + boundaryString + &quot;--&quot; + &quot;\\r\\n&quot;); obos.writeBytes(&quot;\\r\\n&quot;); obos.flush(); obos.close(); InputStream ins = null; int code = conne.getResponseCode(); try &#123; if (code == 200) &#123; ins = conne.getInputStream(); &#125; else &#123; ins = conne.getErrorStream(); &#125; &#125; catch (SSLException e) &#123; e.printStackTrace(); return new byte[0]; &#125; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buff = new byte[4096]; int len; while ((len = ins.read(buff)) != -1) &#123; baos.write(buff, 0, len); &#125; byte[] bytes = baos.toByteArray(); ins.close(); return bytes; &#125; private static String getBoundary() &#123; StringBuilder sb = new StringBuilder(); Random random = new Random(); for (int i = 0; i &lt; 32; ++i) &#123; sb.append(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-&quot;.charAt( random.nextInt(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_&quot;.length()))); &#125; return sb.toString(); &#125; private static String encode(String value) throws Exception &#123; return URLEncoder.encode(value, &quot;UTF-8&quot;); &#125; public static byte[] getBytesFromFile(File f) &#123; if (f == null) &#123; return null; &#125; try &#123; FileInputStream stream = new FileInputStream(f); ByteArrayOutputStream out = new ByteArrayOutputStream(1000); byte[] b = new byte[1000]; int n; while ((n = stream.read(b)) != -1) out.write(b, 0, n); stream.close(); out.close(); return out.toByteArray(); &#125; catch (IOException e) &#123; &#125; return null; &#125;&#125; 3）、创建ImageUtil.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.yuxiang.facelogin.util;import java.util.Base64;import java.util.UUID;import java.util.Base64.Decoder;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;public class ImageUtil &#123; /** * 上传图片到指定位置 * @param request * @param picName 客户端文件的name * @param picPath 文件上传的路径 * @return */ public static File uploadImg(HttpServletRequest request,String picName,String picPath) &#123; String imgData = request.getParameter(picName);//获取客户端传输到服务器的图片 String path = request.getServletContext().getRealPath(&quot;/&quot;+picPath+&quot;/&quot;);//获取指定的图片上传到服务器的路径 String fileName = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;)+&quot;.png&quot;;//给图片一个随机名称 // imageData = data:image/png;base64,XXX*N boolean flag=generateImage(imgData.substring(22), path, fileName);//上传图片 System.out.println(&quot;图片上传:&quot;+flag+&quot;,地址：&quot;+path); return new File(path+&quot;/&quot;+fileName); &#125; /** * * @param imgStr 图片的base64编码文件流 * @param filePath 保存的文件路径 * @param fileName 文件名 * @return */ private static boolean generateImage(String imgStr, String filePath, String fileName) &#123; try &#123; if (imgStr == null) &#123; return false; &#125; Decoder decoder = Base64.getDecoder(); byte[] b = decoder.decode(imgStr); File file = new File(filePath); if (!file.exists()) &#123; file.mkdirs(); &#125; OutputStream out = new FileOutputStream(filePath+fileName); out.write(b); out.flush(); out.close(); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 4）、创建FaceUtil.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package com.yuxiang.facelogin.util;import java.io.File;import java.util.HashMap;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;public class FaceUtil &#123; /** * 根据传入图片进行人脸检测 * @param file 传入的人脸照片 * @return 返回人脸照片的facetoken,如果为空说明图片不符合要求 * @throws Exception */ public static String detect(File file) throws Exception &#123; byte[] buff = HTTPUtil.getBytesFromFile(file); String url = &quot;https://api-cn.faceplusplus.com/facepp/v3/detect&quot;; HashMap&lt;String, byte[]&gt; byteMap = new HashMap&lt;&gt;(); byteMap.put(&quot;image_file&quot;, buff); byte[] bacd = HTTPUtil.post(url, HTTPUtil.map, byteMap); String str = new String(bacd); if(str.indexOf(&quot;error_message&quot;)!=-1) &#123; return null; &#125; JSONObject obj = JSONObject.parseObject(str); int faceNum=obj.getIntValue(&quot;face_num&quot;); if(faceNum==1) &#123; //获取facetoken JSONObject face=(JSONObject) ((JSONArray)obj.get(&quot;faces&quot;)).get(0); String faceToken=face.getString(&quot;face_token&quot;); return faceToken; &#125; return null; &#125; /** * 查询指定的照片是否在人脸集合faceset中存在 * @param faceToken * @return * @throws Exception */ public static boolean search(String faceToken) throws Exception &#123; String url = &quot;https://api-cn.faceplusplus.com/facepp/v3/search&quot;; HTTPUtil.map.put(&quot;face_token&quot;, faceToken); byte[] bacd = HTTPUtil.post(url, HTTPUtil.map, null); HTTPUtil.map.remove(&quot;face_token&quot;); String str = new String(bacd); if(str.indexOf(&quot;error_message&quot;)==-1) &#123; //请求没有错误 JSONObject json = JSONObject.parseObject(str); JSONObject thresholds=(JSONObject) json.get(&quot;thresholds&quot;); Double le5=thresholds.getDouble(&quot;1e-5&quot;); JSONArray results=(JSONArray) json.get(&quot;results&quot;); if(results!=null &amp;&amp; results.size()&gt;=1) &#123; Double confidence=((JSONObject)results.get(0)).getDouble(&quot;confidence&quot;); if(confidence&gt;le5) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 添加人脸到faceset中 * @param face_tokens 要添加的人脸 * @return * @throws Exception */ public static boolean addFace(String face_tokens) throws Exception &#123; if(!getDetail()) &#123;//先获取人脸集合，没有集合就创建一个 System.out.println(&quot;没有获取到指定人脸集合&quot;); boolean res=createFaceSet(); if(!res) &#123; System.out.println(&quot;创建人脸集合出问题了!&quot;); return false; &#125; System.out.println(&quot;创建人脸集合成功！&quot;); &#125; String url = &quot;https://api-cn.faceplusplus.com/facepp/v3/faceset/addface&quot;; HTTPUtil.map.put(&quot;face_tokens&quot;, face_tokens); byte[] bacd = HTTPUtil.post(url, HTTPUtil.map, null); HTTPUtil.map.remove(&quot;face_tokens&quot;); String str = new String(bacd); if(str.indexOf(&quot;error_message&quot;)!=-1) &#123; return false; &#125; return true; &#125; /** * 创建一个人脸的集合 FaceSet，用于存储人脸标识 face_token。 * @return * @throws Exception */ private static boolean createFaceSet() throws Exception &#123; String url = &quot;https://api-cn.faceplusplus.com/facepp/v3/faceset/create&quot;; byte[] bacd = HTTPUtil.post(url, HTTPUtil.map, null); String str = new String(bacd); System.out.println(str); if(str.indexOf(&quot;error_message&quot;)!=-1) &#123; return false; &#125; System.out.println(&quot;创建人脸集合：&quot;+str); return true; &#125; /** * 获取一个faceset * @return * @throws Exception */ private static boolean getDetail() throws Exception &#123; String url = &quot;https://api-cn.faceplusplus.com/facepp/v3/faceset/getdetail&quot;; byte[] bacd = HTTPUtil.post(url, HTTPUtil.map, null); String str = new String(bacd); System.out.println(&quot;facesetDetail：&quot; + str); if(str.indexOf(&quot;error_message&quot;)!=-1) &#123; return false; &#125; return true; &#125;&#125; 5）、创建FaceServlet.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.yuxiang.facelogin.servlet;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.yuxiang.facelogin.util.FaceUtil;import com.yuxiang.facelogin.util.ImageUtils;@WebServlet(&quot;/faceController&quot;)public class FaceServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public FaceServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取用户上传图片 File file = ImageUtils.uploadImg(request, &quot;imgData&quot;, &quot;upimg&quot;); boolean res = false; boolean deleteFlag = true; try &#123; // 查看图片是否包含人脸 String faceToken = FaceUtil.detect(file); if (faceToken != null) &#123; // 包含人脸 // 查找是否包含在人脸集合中 res = FaceUtil.search(faceToken); String type = request.getParameter(&quot;type&quot;); // 如果是注册请求，测判断faceSet中是否有该人脸，有的话注册失败，否则将人脸添加到集合 if (&quot;register&quot;.equals(type)) &#123; if (res) &#123; res = false; &#125; else &#123; // 添加人脸到faceSet并保存到本地 FaceUtil.addFace(faceToken); deleteFlag = false; &#125; &#125; &#125; else &#123; // 不包含人脸 &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; if (deleteFlag) &#123; file.delete(); &#125; PrintWriter printWriter = response.getWriter(); String msg = &quot;&#123;\\&quot;success\\&quot;: &quot; + res +&quot;&#125;&quot;; printWriter.write(msg); printWriter.close(); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 运行测试即可","categories":[{"name":"业务功能","slug":"业务功能","permalink":"http://yuxiangai.cn/categories/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"face++","slug":"face","permalink":"http://yuxiangai.cn/tags/face/"}]},{"title":"ECS搭建Leanote云笔记本","slug":"ECS搭建Leanote云笔记本","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2020/11/03/ECS搭建Leanote云笔记本/","link":"","permalink":"http://yuxiangai.cn/2020/11/03/ECS%E6%90%AD%E5%BB%BALeanote%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/","excerpt":"使用阿里云ECS搭建Leanote云笔记本","text":"使用阿里云ECS搭建Leanote云笔记本 开通、连接资源阿里云免费体验搭建Leanote云笔记本。 点击左侧免费开通，创建资源。 连接服务器。 用 CMD Powershell Terminal均可, 我在此使用CMD 命令：ssh [username]@[ipaddress] 安装MongoDB MongoDB是一个基于分布式文件存储的高性能数据库，介于关系数据库和非关系数据库之间，它支持的数据结构非常松散是类似于json和bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Leanote云笔记使用MongoDB作为后端数据库。 1）、安装MongoDB。 1234567891011# 配置MongoDB的yum源vim /etc/yum.repos.d/mongodb-org-3.4.repo# 输入以下内容 *************[mngodb-org]name=MongoDB Repositorybaseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/4.0/x86_64/gpgcheck=0enabled=1# *************# 安装mongodbyum install -y mongodb-org 2）、 执行以下命令，启动MongoDB服务。 1systemctl start mongod 3）、执行以下命令，查看MongoDB运行状态。 1systemctl status mongod 安装Leanote1）、 下载Leanote二进制安装包。 1wget https://nchc.dl.sourceforge.net/project/leanote-bin/2.6.1/leanote-linux-amd64-v2.6.1.bin.tar.gz 2）、 解压安装包。 1tar -zxvf leanote-linux-amd64-v2.6.1.bin.tar.gz 3）、修改配置文件。 1234# 使用vim打卡leanote/conf/app.confvim leanote/conf.app.conf# 修改 app.secret的值app.secret=V85ZzBeTnzpsHyjQX4zukbQ8qqtju9y2aDM55VWxAHjk234kfHlssAiIn3891 4）、初始化数据库。 1mongorestore -h localhost -d leanote --dir /root/leanote/mongodb_backup/leanote_install_data/ 5）、启动服务。 nohup 命令解释 nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 用法: nohup COMMAND [ARG]… or: nohup OPTION 1234nohup bash /root/leanote/bin/run.sh &gt; /root/leanote/run.log 2&gt;&amp;1 &amp;# 可以使用jobs命令查看服务运行状态[root@iZ leanote_install_data]# jobs[1]+ Running nohup bash /root/leanote/bin/run.sh &gt; /root/leanote/run.log 2&gt;&amp;1 &amp; 6）、访问云笔记。 浏览器访问http://&lt;ECS公网地址&gt;:9000，默认账号密码admin,abc123。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"云笔记本","slug":"阿里云/云笔记本","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"Leanote","slug":"Leanote","permalink":"http://yuxiangai.cn/tags/Leanote/"}]},{"title":"git简介与命令使用","slug":"Git简介与命令使用","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/11/02/Git简介与命令使用/","link":"","permalink":"http://yuxiangai.cn/2020/11/02/Git%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/","excerpt":"Git入门和常用命令操作","text":"Git入门和常用命令操作 git命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 比较文件不同git diff HEAD# 工作区与本地仓库比较不同git diff --cached# 工作区与缓存区比较不同# 从缓存区中删除文件 但 不删除工作区中文件git reset HEAD -- [文件名]git rm --cached [文件名]# 从缓存区中删除文件 并且 删除工作区中的文件git rm [文件名]# 将缓存区中的文件重命名并重新添加到缓存区git mv [原文件名] [更改后文件名]# 创建分支git branch [分支名] # // 如果分支名不写则列出所有分支# 切换分支git checkout [分支名]# 删除分支git checkout -d [分支名]# 将指定分支 与 当前分支合并，当出现冲突时需要自己解决冲突后，commit来完成 merge操作git merge [分支名] # 查看历史版本git log git log --oneline # 仅仅一行显示git log --graph # 查看历史中什么时候出现了分支、合并。git log --reverse # 逆向查看历史中什么时候出现分支、合并。git log --author=[作者]git 标签git tag # 查看所有标签# git tag 默认为当前HEAD指向的版本添加标签 ，可以添加之前版本的hansh值来为之前的版本添加hash值git tag -a [标签名] -m [&#x27;描述信息&#x27;] [之前版本的hash值]# 添加远程库git remote add [远程仓库别名] [url]# 查看当前远程库git remotegit remote -v# 提取远程仓库git fetch # 该命令执行完后需要执行git merge 远程分支到你所在的分支。git pull # 从远端仓库提取数据并尝试合并到当前分支# 推送到远程仓库git push [远程仓库别名] [branch]# 删除远程仓库git remote rm [别名] github搜索 按名字搜索 in:name [spring boot] 按star搜索 in:name [spring boot/spring] stars:&gt;数量(300) 按fork数搜索 in:name [spring boot/spring] stars:&gt;数量(300) forks:&gt;数量 按readme搜索 in:readme [spring boot] [stars:&gt;数量(300)] [forks:&gt;数量] 按描述搜索 in:description [spring cloud] [language:java] [上传时间 pushd:&gt;日期] in:description [爬虫] language:python stars:&gt;200 明确搜索某个人或组织的仓库 user:userName user:userName language:java org:spring-cloud","categories":[{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/tags/git/"}]},{"title":"PolarDB和ECS搭建门户网站","slug":"PolarDB和ECS搭建门户网站","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/11/02/PolarDB和ECS搭建门户网站/","link":"","permalink":"http://yuxiangai.cn/2020/11/02/PolarDB%E5%92%8CECS%E6%90%AD%E5%BB%BA%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99/","excerpt":"使用PolarDB和ECS搭建门户网站","text":"使用PolarDB和ECS搭建门户网站 PolarDB简介PolarDB是阿里云自研的下一代关系型云数据库，有三个独立的引擎，分别可以100%兼容MySQL、100%兼容PostgreSQL、高度兼容Oracle语法，存储容量最高可达100TB，单库最多可扩展到16个节点，适用于企业多样化的数据库应用场景。 PolarDB采用存储和计算分离的架构，所有计算节点共享一份数据，提供分钟级的配置升降级、秒级的故障恢复、全局数据一致性和免费的数据备份容灾服务。PolarDB既融合了商业数据库稳定可靠、高性能、可扩展的特征，又具有开源云数据库简单开放、自我迭代的优势，例如PolarDB MySQL性能最高可以提升至MySQL的6倍，而成本只有商用数据库的1/10。集群架构，计算与存储分离。 开通、连接资源PolarDB免费上手体验。 单击免费开通创建所需资源。 连接服务器。使用CMD、Powershell、Xshell等工具都可以。 创建PolarDB数据库账号 单击页面左侧云产品资源下的一键复制登录url 。 在浏览器中打开，使用RAM用户 登录。 在 阿里云控制台首页 左侧导航栏，依次单击 产品与服务 &gt; 云数据库PolarDB ，进入 云数据库PolarDB管理控制台 。 单击左侧 集群列表 ，然后选择云产品资源提供的地域。 创建数据库账号。 1）、 在 集群列表 页面，单击 集群ID ，进入 集群详情界面 。 2）、单击左侧导航栏 配置与管理 &gt; 账号管理 。 3）、单击左上方 创建账号 。 4）、设置账号密码，然后单击 确定 。 创建数据库。 1）、在实例详情页，单击左侧导航栏的 数据库管理 ，然后单击 创建数据库 。 2）、参考说明配置数据库信息，然后单击 创建 。 配置访问白名单。 安装环境安装Apache、MySQL和PHP的环境。 安装Apache服务及其扩展包。 1yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql 安装PHP环境。 1yum -y install php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap 下载并安装MySQL。 123wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-server 启动MySQL数据库。 12systemctl start mysqldsystemctl status mysqld 搭建门户网站 安装git。 1yum install git -y 下载PbootCMS源码文件。 PbootCMS是全新内核且永久开源免费的PHP企业网站开发建设管理系统，是一套高效、简洁、 强悍的可免费商用的PHP CMS源码，能够满足各类企业网站开发建设的需要。系统采用简单到想哭的模板标签，只要懂HTML就可快速开发企业网站。 1cd ~ &amp;&amp; git clone https://gitee.com/hnaoyun/PbootCMS.git 将安装包拷贝到Apache的wwwroot目录下。 1cp -r PbootCMS/* /var/www/html/ 修改站点根目录文件权限。 1chmod -R a+w /var/www/html 向数据库中导入CMS的初始数据。 1）、获取sql文件。 1sql_file=&quot;/var/www/html/static/backup/sql/&quot;$(ls /var/www/html/static/backup/sql/) &amp;&amp; echo $sql_file 2）、连接数据库，并导入CMS的初始数据。 数据库连接地址：在开通资源左侧处 1234mysql -h&lt;数据库连接地址&gt; -u&lt;用户名&gt; -p&lt;密码&gt;sql_file=&quot;/var/www/html/static/backup/sql/&quot;$(ls /var/www/html/static/backup/sql/) &amp;&amp;mysql -hpc-uf606ov9nvsq2sh62.mysql.polardb.rds.aliyuncs.com -uyuxiang_test -pYuxiang123 -Dpbootcms &lt; $sql_file 3）、修改CMS系统数据库配置。 12345678910111213cat &gt; /var/www/html/config/database.php &lt;&lt; EOF&lt;?phpreturn array( &#x27;database&#x27; =&gt; array( &#x27;type&#x27; =&gt; &#x27;mysqli&#x27;, // 数据库连接驱动类型: mysqli,sqlite,pdo_mysql,pdo_sqlite &#x27;host&#x27; =&gt; &#x27;数据库连接地址&#x27;, // PolarDB数据库链接地址 &#x27;user&#x27; =&gt; &#x27;yuxiang_user&#x27;, // PolarDB数据库的用户名 &#x27;passwd&#x27; =&gt; &#x27;Yuxiang123&#x27;, // PolarDB数据库的密码 &#x27;port&#x27; =&gt; &#x27;3306&#x27;, // 数据库端口 &#x27;dbname&#x27; =&gt; &#x27;pbootcms&#x27; //数据库名称 ));EOF 在ECS实例列表页面，单击已创建的ECS实例ID链接进入ECS详情页，左侧导航栏，单击 本实例安全组 ，然后单击安全组的ID链接查看安全组配置。 访问程序。 重启 Apache服务。 1systemctl restart httpd 在浏览器地址栏输入云服务器的公网IP地址，进入门户网站首页。 系统后台默认访问路径为http://&lt;ECS公网IP地址&gt;/admin.php。默认账号为admin，密码为123456。 至此您已完成门户网站的搭建，您可以根据公司的需求自定义门户网站的内容。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB搭建网站","slug":"阿里云/PolarDB搭建网站","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/PolarDB%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB","slug":"PolarDB","permalink":"http://yuxiangai.cn/tags/PolarDB/"}]},{"title":"阿里云SLB负载均衡实践","slug":"SLB负载均衡实践","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2020/11/01/SLB负载均衡实践/","link":"","permalink":"http://yuxiangai.cn/2020/11/01/SLB%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E8%B7%B5/","excerpt":"基于阿里云ECS和SLB实现负载均衡","text":"基于阿里云ECS和SLB实现负载均衡 SLB简介负载均衡（Server Load Balancer）是将访问流量根据转发策略分发到后端多台云服务器（ECS实例）的流量分发控制服务。负载均衡扩展了应用的服务能力，增强了应用的可用性。 负载均衡通过设置虚拟服务地址，将添加的ECS实例虚拟成一个高性能、高可用的应用服务池，并根据转发规则，将来自客户端的请求分发给云服务器池中的ECS实例。 负载均衡默认检查云服务器池中ECS实例的健康状态，自动隔离异常状态的ECS实例，消除了单台ECS实例的单点故障，提高了应用的整体服务能力。此外，负载均衡还具备抗DDoS攻击的能力，增强了应用服务的防护能力。 架构负载均衡服务主要有三个核心概念： 负载均衡实例 （Server Load Balancer instances） 一个负载均衡实例是一个运行的负载均衡服务，用来接收流量并将其分配给后端服务器。要使用负载均衡服务，您必须创建一个负载均衡实例，并至少添加一个监听和两台ECS实例。 监听 （Listeners） 监听用来检查客户端请求并将请求转发给后端服务器。监听也会对后端服务器进行健康检查。 后端服务器（Backend Servers） 一组接收前端请求的ECS实例。您可以单独添加ECS实例到服务器池，也可以通过虚拟服务器组或主备服务器组来批量添加和管理。 开通资源阿里云SLB负载均衡，免费开通体验。 左侧显示相关资源信息。 查看云服务器状态打开浏览器，访问两台ECS服务器地址，查看状态。 负载均衡配置 点击左侧导航栏处的 云产品资源 查看资源信息，点击 一键复制url，用浏览器登录控制台。 输入实验提供的 子用户名称 和 子用户密码 ，完成后点击 登录 。登录阿里云管理控制台。 在产品与服务中搜索负载均衡，选择弹性计算下的负载均衡。 选择华东2（上海），选择实例 -》实例管理，点击点我开始配置。 通过负载均衡业务配置向导，配置负载均衡的 监听端口、后端服务器 和 健康检查 1）、在 后端服务器 页面，监听请求转发至 默认服务器组，在已添加服务器处点击 继续添加 。 2）、在弹出的待添加服务器页面，在预先配置好的两台云服务器前打勾选择，然后点击下一步，之后再点击 添加； 3）、设置端口号为80，下一步。 刷新负载均衡实例查看状态。 访问测试权重相同此时，两台后端服务器的权重比例相同。 在控制台点击左侧 实例管理 ，在右侧页面中的红框处看到负载均衡的 服务地址（也就是 云产品资源 提供的 负载均衡 的 IP地址）。 在浏览器中新建页面，并访问 负载均衡 的 服务地址 。界面显示的 后端服务器IP 为 云服务器ECS-1（或 云服务器ECS-2） 的 内网地址 。 刷新 浏览页面，显示的 后端服务器IP 将发生变化，变为 云服务器ECS-2（或 云服务器ECS-1）的 内网地址 ； 说明：界面显示的地址为内网地址，这是因为负载均衡访问后端ECS实例，是通过内网访问的。 重复刷新操作，观察 后端服务器IP 是在两个云服务器的 内网地址 间轮流更换，可以减轻单台服务器的负载压力，从而确保业务的持续性。 权重不同修改后端服务器权重，验证负载均衡向后端服务器发送请求的比例是按照权重的比例调整的。 进入实例管理 页面，点击该实例的 默认服务器组 ； 选中 已添加的服务器 ，列表中，勾选下方的勾选框 ，然后点击 修改权重 ； 返回已添加的服务器的页面，查看到两台 ECS实例 的权重分别为 30 和 90 ，并记录对应的 ECS实例 内网地址。 浏览器中，刷新多次负载均衡 服务地址 的页面，并记录页面显示的 后端服务器IP 。可以发现：每 4 次刷新，将有 3 次访问 权重 为 90 的 ECS实例，1 次访问权重为 30 的 ECS实例。 结果：证明用户可以根据实际情况调整负载均衡器的请求分发，一般将配置高的服务器设置的权重调高，配置较低的服务器设置的权重调低。这样可以避免在高并发时，配置较低的服务器因为压力较大服务异常的发生。 模拟宕机首先开启负载均衡的 会话保持 功能。 1）点击左侧 监听 ，监听页面点击右侧的 修改监听配置 。 2） 配置监听页面的 高级配置 处，点击 修改 ； 3）开启 会话保持 ，超时时间 输入 180 （即 3 分钟）；完成后点击 下一步 4）下面的 后端服务器、健康检查 和 配置审核 页面都采用默认值 ，依次完成配置。 返回到 监听 页面 ，会话保持 状态 已开启 。 再次在浏览器中输入 负载均衡 的 IP地址 ，多次刷新，发现在会话保持的超时时间内请求只会分发到某一台 ECS 上（究竟是哪一台 ECS 没有规定），时间超出后，重新按照权重比例分发。 我们关掉刚才访问的那台机器。 返回负载均衡管理控制台，在默认服务器组页面中点击右上角的【刷新】，页面刷新后被停止的 ECS 的 状态 变为 已停止。监听 页面，也出现 异常 提示 。 点击左上角的 【实例管理 】，返回负载均衡管理控制台主页面，异常 报警也会出现。 再次刷新浏览器中 负载均衡 的 IP地址 ，此时，请求发送到 健康检查状态 为 正常 的ECS上。 结果：当某一台 ECS 出现异常后，负载均衡会自动将请求发送到健康检查状态正常的 ECS 上。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"SBL负载均衡","slug":"阿里云/SBL负载均衡","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/SBL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"SLB","slug":"SLB","permalink":"http://yuxiangai.cn/tags/SLB/"}]},{"title":"阿里云ECS搭建Docker环境","slug":"ECS搭建Docker环境","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2020/10/31/ECS搭建Docker环境/","link":"","permalink":"http://yuxiangai.cn/2020/10/31/ECS%E6%90%AD%E5%BB%BADocker%E7%8E%AF%E5%A2%83/","excerpt":"基于阿里云ECS搭建Docker环境、服务简单部署","text":"基于阿里云ECS搭建Docker环境、服务简单部署 简介Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。 Docker名词解释： 镜像：Docker 镜像是容器应用打包的标准格式，是创建容器的模板。 容器：一个通过 Docker 镜像创建的运行时实例，一台主机可运行多个同一镜像的容器实例。 安装、启动 首先开通阿里云ECS资源，免费体验，还在等什么呢。 连接。 用 CMD Powershell Terminal均可, 我在此使用CMD 命令：ssh [username]@[ipaddress] 安装Docker CE。 1234567891011# 1. 安装Docker依赖库yum install -y yum-utils device-mapper-persistent-data lvm2# 2. 安装Docker CE的软件源信息yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 3. 安装Docker CEyum makecache fastyum -y install docker-ce# 4. 启动Docker服务systemctl start docker# 查看Docker启动情况systemctl status docker 配置镜像加速Docker的默认官方远程仓库是hub.docker.com，由于网络原因，下载一个Docker官方镜像可能会需要很长的时间，甚至下载失败。为此，阿里云容器镜像服务ACR提供了官方的镜像站点，从而加速官方镜像的下载。下面介绍如何使用阿里云镜像仓库。 使用子账户登录阿里云。 在页面左侧资源栏点击 一键复制登录url，在浏览器中打开。进行RAM用户登录。 在左侧产品与服务中搜索镜像。 单击容器镜像服务，若提示未开通服务，关闭即可。 单击【镜像中心】 &gt; 【镜像加速器】，可以看到阿里云为您提供了一个专属的镜像加速地址。 配置Docker仓库地址为在 【镜像加速器】中的加速器地址。 1234567891011[root@i1kzth4Z ~]# ls /etc/docker/key.json[root@i1kzth4Z ~]# cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&gt; &#123;&gt; &quot;registry-mirrors&quot;: [&quot;https://xxxx.aliyuncs.com&quot;]&gt; &#125;&gt; EOF[root@i1kzth4Z ~]# cat /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://xxxx.aliyuncs.com&quot;]&#125; 重新加载配置文件，重启服务。 1234# 加载配置文件systemctl daemon-reload# 重启服务systemctl restart docker Docker常用命令docker search 根据名字搜索镜像 用法：docker search [OPTIONS] TERM 12345678[root@iicxcxq7nz ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 13942 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1902 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 791 [OK]linuxserver/nginx An Nginx container, brought to you by LinuxS… 128 jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 106 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 101 [OK] docker pull 从远程仓库拉去镜像 用法：docker pull [OPTIONS] NAME[:TAG|@DIGEST] 12345678910[root@iicxcxq7nz ~]# docker pull nginx:latestlatest: Pulling from library/nginxbb79b6b2107f: Already exists 111447d5894d: Pull complete a95689b8e6cb: Pull complete 1a0022e444c2: Pull complete 32b7488a3833: Pull complete Digest: sha256:ed7f815851b5299f616220a63edac69a4cc200e7f536a56e421988da82e44ed8Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest docker images 查看本地镜像列表 用法：docker images [OPTIONS] [REPOSITORY[:TAG]] 123456789[root@iicxcxq7nz ~]# docker images nginx:latestREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f35646e83998 2 weeks ago 133MB[root@iicxcxq7nz ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f35646e83998 2 weeks ago 133MBmysql 5.7 42cdba9f1b08 2 weeks ago 448MBnginx 1.12 4037a5562b03 2 years ago 108MB docker run 通过镜像开始一个运行实例 用法：docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 1234567[root@iicxcxq7nz ~]# docker run --name mysql \\-p 3306:3306 \\-v /home/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /home/mysql/logs:/logs \\-v /home/mysql/data/mysql:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:5.6 \\ --name：设置容器实例名称 -p：宿主机与容器端口绑定 -v：挂载目录或数据卷，将容器内的文件夹与宿主机文件夹映射，方便修改容器内的文件。 -e：设置容器内MySQL服务Root用户密码 -d：后台守护运行，返回容器实例ID docker ps 查看容器 用法：docker ps [OPTIONS] 参数: -a：显示全部 -n &lt;num&gt;：显示最新运行的个容器 -l：显示最新创建的容器(包括所有状态) -q：仅显示容器ID -s：显示容器总大小 123456[root@iicxcxq7nz demo]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES33a5981c417d nginx:latest &quot;/docker-entrypoint.…&quot; 8 minutes ago Up 8 minutes 0.0.0.0:8080-&gt;80/tcp nginx-test[root@iicxcxq7nz demo]# docker ps -sCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE33a5981c417d nginx:latest &quot;/docker-entrypoint.…&quot; 8 minutes ago Up 8 minutes 0.0.0.0:8080-&gt;80/tcp nginx-test 1.29kB (virtual 133MB) 搭建Nginx服务 拉取最新Nginx镜像。 1docker pull nginx:latest 运行容器。 1docker run --name nginx-test -p 8080:80 -d nginx:latest 运行结果如下 在浏览器地址栏输入http://&lt;公网地址&gt;:8080访问Nginx服务。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Docker","slug":"阿里云/Docker","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/Docker/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"Docker","slug":"Docker","permalink":"http://yuxiangai.cn/tags/Docker/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"阿里云ECS搭建FTP服务","slug":"ECS搭建FTP服务","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2020/10/30/ECS搭建FTP服务/","link":"","permalink":"http://yuxiangai.cn/2020/10/30/ECS%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1/","excerpt":"基于ECS，使用vsftpd搭建FTP服务","text":"基于ECS，使用vsftpd搭建FTP服务 环境 CentOS Linux release 7.3.1611 vsftpd-3.0.2-27.el7.x86_64 前置知识 chmod命令 Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 语法&amp;例子 123456789chmod [-cfvR] [--help] [--version] mode file...# u：用户 g：组 o：其他 a：全部# 将文件 file1.txt 设为所有人皆可读取chmod ugo+r file1.txt # 或 chmod a+r file1.txt# 也可以用数字代替 4=r，2=w，1=x # 将目前目录下的所有文件与子目录皆设为任何人可读取chmod 777 * # 或 chmod a+rwx * chown命令 Linux chown（英文全拼：change owner）命令用于设置文件所有者和文件关联组的命令。 Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 chown 需要超级用户 root 的权限才能执行此命令。 语法&amp;例子 1234567chown [-cfhvR] [--help] [--version] user[:group] file...# 将文件 file1.txt 的拥有者设为 yuxiang，群体的使用者 yuxianggroupchown yuxiang:yuxianggroup file1.txt# 将当前前目录下的所有文件与子目录的拥有者皆设为 yuxiang，群体的使用者 yuxianggroupchown -R yuxiang:yuxianggroup *# -R : 处理指定目录以及其子目录下的所有文件 sed命令 Linux sed 命令是利用脚本来处理文本文件。 sed 可依照脚本的指令来处理、编辑文本文件。 Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 ftp客户端命令 123456789101112131415161718192021222324252627282930#进入ftp客户端ftp#打开ftp服务器&gt;open xxx.xxx.xxx.xxx#查看远程目录&gt;dir#查看本地目录&gt;!dir #指定本地目录&gt;lcd#切换远程目录&gt;cd 目录#上传文件&gt;put 文件名#上传文件,支持*通配&gt;mput 文件名#下载文件&gt;get 文件名#下载文件,支持*通配&gt;mget 文件名#删除远程文件&gt;delete 文件名#退出服务器&gt;bye 开通、连接资源阿里云ECS搭建FTP服务开通资源，免费体验。 连接 ：使用CMD、Powershell、Xshell等工具都可以。 安装、启动vsftpd1234567# 1. 安装yum install -y vsftpd# 2. 运行systemctl start vsftpd.service# 3. 查看运行结果systemctl status vsftpd.servicenetstat -tunap | grep ftp 配置vsftpdvsftpd（very secure FTP daemon）是一款在Linux发行版中最受推崇的FTP服务器。vsftpd支持匿名访问和本地用户模式两种访问方式。匿名访问方式任何用户都可以访问搭建的FTP服务；本地用户模式只支持添加的本地用户访问搭建的FTP服务。 说明: 匿名用户模式和本地用户模式只可同时配置一种。 匿名用户模式 修改配置文件vsftpd.conf。 1vim /etc/vsftpd/vsftpd.conf 将匿名长传权限anon_upload_enable=YES的注释解开。 退出编辑模式，输入:wq保存并退出vim编辑器。 为FTP用户添加写权限。 1chmod o+w /var/ftp/pub/ 重启服务。 1systemctl restart vsftpd.service 访问测试。 在/var/ftp/pub目录下创建hello.js文件 12345678[root@ic5x28dikeZ ~]# cd /var/ftp/pub/[root@ic5x28dikeZ pub]# touch hello.js[root@ic5x28dikeZ pub]# cat &gt;&gt; ./hello.js &lt;&lt; EOF&gt; console.log(&#x27;hello world vsftpd&#x27;);&gt; EOF[root@c5x28dikeZ pub]# cat hello.jsconsole.log(&#x27;hello world vsftpd&#x27;);[root@ic5x28dikeZ pub]# 本地用户模式 为FTP服务创建一个Liunx用户。 1234# 创建用户adduser ftptest# 设置密码passwd ftptest 创建一个供FTP服务使用的文件目录。 1mkdir /var/ftp/test 更改/var/ftp/test目录的拥有者为ftptest. 1chowm -R ftptest:ftptest /var/ftp/test 修改/etc/vsftpd/vsftpd.conf配置文件。 FTP两种模式：主动模式、被动模式。详细可自行搜索。 主动模式配置 12345678sed -i &#x27;s/anonymous_enable=YES/anonymous_enable=NO/&#x27; /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 sed -i &#x27;s/listen=NO/listen=YES/&#x27; /etc/vsftpd/vsftpd.conf #监听IPv4 sockets sed -i &#x27;s/listen_ipv6=YES/#listen_ipv6=YES/&#x27; /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets sed -i &#x27;s/#chroot_local_user=YES/chroot_local_user=YES/&#x27; /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 sed -i &#x27;s/#chroot_list_enable=YES/chroot_list_enable=YES/&#x27; /etc/vsftpd/vsftpd.conf #启用例外用户名单 sed -i &#x27;s/#chroot_list_file=/chroot_list_file=/&#x27; /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 echo &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf echo &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 被动模式配置 12345678910111213sed -i &#x27;s/anonymous_enable=YES/anonymous_enable=NO/&#x27; /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 sed -i &#x27;s/listen=NO/listen=YES/&#x27; /etc/vsftpd/vsftpd.conf #监听IPv4 sockets sed -i &#x27;s/listen_ipv6=YES/#listen_ipv6=YES/&#x27; /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets sed -i &#x27;s/#chroot_local_user=YES/chroot_local_user=YES/&#x27; /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 sed -i &#x27;s/#chroot_list_enable=YES/chroot_list_enable=YES/&#x27; /etc/vsftpd/vsftpd.conf #启用例外用户名单 sed -i &#x27;s/#chroot_list_file=/chroot_list_file=/&#x27; /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 echo &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf echo &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 echo &quot;pasv_enable=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #开启被动模式 echo &quot;pasv_address=&lt;FTP服务器公网IP地址&gt;&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #本教程中为ECS服务器弹性IP echo &quot;pasv_min_port=20&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最小值 echo &quot;pasv_max_port=21&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最大值 在/etc/vsftpd目录下创建chroot_list文件，并在在文件中写入例外用户名单。 12345#使用vim命令编辑chroot_list文件，添加例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。vim /etc/vsftpd/chroot_list# 添加用户ftptest# 保存退出 说明：没有例外用户时，也必须创建chroot_list文件，内容可为空。 重启服务。 1systemctl restart vsftpd.service 测试。 浏览器访问测试。 1234567891011121314[root@iicxcxq7nz test]# touch TestMain.java[root@iicxcxq7nz test]# cat &gt;&gt; ./TestMain.java &lt;&lt; EOF&gt; public class TestMain &#123;&gt; public static void main(String agrs[]) &#123;&gt; System.out.println(&#x27;hello vsftpd user&#x27;);&gt; &#125;&gt; &#125;&gt; EOF[root@iicxcxq7nz test]# tree /var/ftp/test/test/└── yuxiang └── TestMain.java1 directory, 1 file ftp工具上传测试。","categories":[{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"ftp服务","slug":"阿里云/ftp服务","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/ftp%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://yuxiangai.cn/tags/vsftpd/"}]},{"title":"MySQL索引和事务介绍","slug":"MySQL索引和事务介绍","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2020/10/21/MySQL索引和事务介绍/","link":"","permalink":"http://yuxiangai.cn/2020/10/21/MySQL%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/","excerpt":"MySQL索引介绍和事务演示","text":"MySQL索引介绍和事务演示 环境版本：mysql 8.0.17 MySQL结构SQL语句分类 数据定义语言DDL 数据查询语言DQL 数据操纵语言DML 数据控制功能DCL 索引索引介绍 索引是帮助MySQL高效获取数据的数据结构 索引存储在文件系统中 索引的文件形式与存储引擎有关 索引文件的结构 hash 二叉树 B树 B+树 索引的优点 大大减少了服务器需要扫描的数据量 帮助服务器避免排序和临时表 将随机io变成顺序io 索引的用处 快速查找WHERE子句匹配的行 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行 当有表连接的时候，从替他表检索行数据 查找特定索引列的min或max值 如果排序分组时可在索引的最左前缀上完成的，则对表进行排序和分组 在某些情况下，可以优化查询以检索值而无需查询数据行 从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用到最少行的索引 索引的分类 主键索引 唯一索引 普通索引 全文索引 组合索引 技术名词回表 InnoDB的索引实现，InnoDB有两大类索引： 聚集索引 非聚集索引 InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引： （1）如果表定义了Primary Key，则Primary Key就是聚集索引； （2）如果表没有定义Primary Key，则第一个not NULL unique列是聚集索引； （3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引； 当为name字段也建立索引，并按照name字段查询行内全部数据时会触发回表。 1explain select * from u_user where name &#x3D; &#39;li&#39;\\G 覆盖索引 当查找的数据只通过一个索引树就可以得到结果，无需回表。 1explain select id, name from u_user where name &#x3D; &#39;li&#39;\\G 最左匹配 以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。 索引下推 MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 前缀索引 索引的匹配方式1234567891011# 员工表create table staffs ( id int PRIMARY key auto_increment, name VARCHAR(24) not null COMMENT &#39;姓名&#39;, age int not null COMMENT &#39;年龄&#39;, pos VARCHAR(20) not null COMMENT &#39;职位&#39;, add_time TIMESTAMP not null COMMENT &#39;入职时间&#39;) CHARSET utf8 comment &#39;员工记录表&#39;;# 添加组合索引alter table staffs add index idx_nap(name,age,pos); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 查看索引mysql&gt; show index from staffs\\G*************************** 1. row *************************** Table: staffs Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL*************************** 2. row *************************** Table: staffs Non_unique: 1 Key_name: idx_nap Seq_in_index: 1 Column_name: name Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL*************************** 3. row *************************** Table: staffs Non_unique: 1 Key_name: idx_nap Seq_in_index: 2 Column_name: age Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL*************************** 4. row *************************** Table: staffs Non_unique: 1 Key_name: idx_nap Seq_in_index: 3 Column_name: pos Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment: Visible: YES Expression: NULL4 rows in set (0.01 sec) 全值匹配： 123456789101112131415mysql&gt; explain select * from staffs where name &#x3D; &#39;July&#39; and age &#x3D; &#39;23&#39; and pos&#x3D;&#39;dev&#39;\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: refpossible_keys: idx_nap key: idx_nap key_len: 140 ref: const,const,const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 注意key_len, 利用key_len可以推出用到的索引 140 = { name的varchar(24) + pos的varchar(20) } * 3(utf8字符占三个字节) + int的4 + 每个varchar在存储时会多占用2个字节所以 name + pos (4) 就等于 140 匹配最左前缀： 123456789101112131415mysql&gt; explain select * from staffs where name &#x3D; &#39;July&#39; and age &#x3D; 2\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: refpossible_keys: idx_nap key: idx_nap key_len: 78 # 24 * 3 + 4 + varchar额外占用的2个字节 ref: const,const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 匹配列前缀：like 1234567891011121314151617181920212223242526272829303132# % 符号在后可以触发索引mysql&gt; explain select * from staffs where name like &#39;J%&#39; and age &#x3D; 23\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: rangepossible_keys: idx_nap key: idx_nap key_len: 78 ref: NULL rows: 1 filtered: 100.00 Extra: Using index condition1 row in set, 1 warning (0.00 sec)# % 符号在前无法触发索引mysql&gt; explain select * from staffs where name like &#39;%J%&#39; and age &#x3D; 23\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 匹配范围值：&gt;,&lt; 123456789101112131415mysql&gt; explain select * from staffs where name &gt; &#39;yuxiang&#39;\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: staffs partitions: NULL type: rangepossible_keys: idx_nap key: idx_nap key_len: 74 ref: NULL rows: 1 filtered: 100.00 Extra: Using index condition1 row in set, 1 warning (0.00 sec) 当用到 &gt; 或 &lt; 等范围查询时，在范围查询后面的字段将不会使用索引 事务事务的基本要素1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。（通过undo log实现） 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。（通过原子性、隔离性、持久性实现） 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。（通过读写锁+MVCC实现） 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。（通过redo log实现） 事务的并发问题1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 MySQL默认事务隔离级别。 1234567mysql&gt; show variables like &#39;TRANSACTION_isolation&#39;;+-----------------------+-----------------+| Variable_name | Value |+-----------------------+-----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+1 row in set, 1 warning (0.01 sec)&#96;1&#96; 演示环境搭建 1234567# 创建数据库create database yuxiang;use yuxiang;# 创建表create table tbl(id int primary key,name varchar(10));# 插入数据insert into tbl values(1,&#39;zhangsan&#39;),(2,&#39;wangwu&#39;),(3,&#39;lisi&#39;); 读未提交打开两个MySQL客户端，一同设置如下，两个客户端我们简称m1、m2。 12# 设置事务自动提交关闭。set autocommit &#x3D; 0; 12# 设置事务隔离级别。set session transaction isolation level read uncommitted; 1）、在m1、m2中开启事务。 1begin; 2）、此时m1、m2两个节点查询表数据一致，我们在m1更新一条数据。 1update tbl set name&#x3D;&quot;1111&quot; where id&#x3D;1; 3）、再m2中查询表数据，发现表数据也更改了。 此时m2节点虽然开启了事务，但是却读取到了m1节点修改且并未提交的结果，这个就是读未提交。 读未提交会产生【脏读、不可重复读、幻读】问题。 读已提交打开两个MySQL客户端，一同设置如下，两个客户端我们简称m1、m2。 12# 设置事务自动提交关闭。set autocommit &#x3D; 0; 12# 设置事务隔离级别。set session transaction isolation level read committed; 1）、在m1、m2中开启事务。 1begin; 2）、此时m1、m2两个节点查询表数据一致，我们在m1更新一条数据。 1update tbl set name&#x3D;&quot;2222&quot; where id&#x3D;2; 3）、在m2中查询表数据，发现表数据没有更改。 1select * from tbl; 4）、在m1中，提交事务。 1commit; 5）、此时m2节点中再次查询，则会查看到m1更改的后的数据。 此时m2节点虽然开启了事务，但是却读取到了m1节点修改且提交后的结果，这个就是读已提交。 读已提交会产生【不可重复读、幻读】问题，但是解决了【脏读】问题。 可重复读打开两个MySQL客户端，一同设置如下，两个客户端我们简称m1、m2。 12# 设置事务自动提交关闭。set autocommit &#x3D; 0; 12# 设置事务隔离级别。set session transaction isolation level repeatable read; 1）、在m1、m2中开启事务。 1begin; 2）、此时m1、m2两个节点查询表数据一致，我们在m1更新一条数据。 1update tbl set name&#x3D;&quot;3333&quot; where id&#x3D;3; 3）、在m2中查询表数据，发现表数据没有更改。 1select * from tbl; 4）、在m1中，提交事务。 1commit; 5）、此时m2节点中再次查询，发现表数据仍然没有更改。 6）、将m2事务提交，重新查询表数据，则会看到m1修改后的数据。 此时m2节点开启了事务，并没有读到m1节点修改且提交后的结果，这个就是可重复读。 可重复读会出现【幻读】问题，解决了【脏读、不可重复读】问题。 串行化","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/categories/MySQL/"},{"name":"MySQL索引","slug":"MySQL/MySQL索引","permalink":"http://yuxiangai.cn/categories/MySQL/MySQL%E7%B4%A2%E5%BC%95/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/tags/MySQL/"}]},{"title":"redis介绍和使用","slug":"Redis介绍和使用","date":"un00fin00","updated":"un55fin55","comments":true,"path":"2020/10/18/Redis介绍和使用/","link":"","permalink":"http://yuxiangai.cn/2020/10/18/Redis%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"redis的介绍、安装、使用和Liunx高级命令","text":"redis的介绍、安装、使用和Liunx高级命令 环境 Aliyun CentOS Linux 7 Redis 5.X 简介Redis是一个开源（BSD许可），内存中的数据结构存储，用作数据库、缓存和消息代理。它支持诸如字符串、哈希、列表、集合、带范围查询的排序集、位图、超日志、带有radius查询和流的地理空间索引等数据结构。Redis内置了复制、Lua脚本、LRU逐出、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区来提供高可用性。 下载安装12345678# 安装wget工具yum install wget -y# 下载Rediswget https://download.redis.io/releases/redis-5.0.5.tar.gz# 解压缩tar -zxvf redis-5.0.5.tar.gzcd redis-5.0.5 &amp;&amp; ls -lh# 此处推荐查看 README.md文件，该文件介绍了Redis如何安装，也可以按照我的操作进行 123456# 安装环境，否则可能会编译出错yum install gcc -y# 编译，安装，会默认安装到 /usr/local/bin 中make &amp;&amp; make install# 如果编译失败，则使用 make distclean 清楚编译失败的文件# 进入 redis目录中的 utils目录下，执行 ./install_server.sh 根据问题进行操作即可 验证服务启动状态service redis_6379 status 或 systemctl status redis_6379 strace使用strace 是 Linux 环境下的一款程序调试工具，用来监察一个应用程序所使用的系统呼叫及它所接收的系统信息。 123456# 安装yum install strace -y# 在 root 目录下创建 stracedir 文件夹cd ~ &amp;&amp; mkdir stracedir# 启动监控 -ff:监控主线程和所有主线程创建的线程 -o:追踪日志输出目录strace -ff -o ~/stracedir/ooxx ./Redis-server 查看 /root/stracedir文件夹下生成的文件，由名字和线程PID组成。 连接输入redis-cli即可连接 123456789101112131415[root@ctl ~]# redis-cli -h # 查看命令帮助，此处列出一部分redis-cli 5.0.5Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]] -h &lt;hostname&gt; Server hostname (default: 127.0.0.1). -p &lt;port&gt; Server port (default: 6379). -s &lt;socket&gt; Server socket (overrides hostname and port). -a &lt;password&gt; Password to use when connecting to the server. You can also use the REDISCLI_AUTH environment variable to pass this password more safely (if both are used, this argument takes predecence). -u &lt;uri&gt; Server URI. -n &lt;db&gt; Database number. --raw Use raw formatting for replies (default when STDOUT is not a tty). redis五大类型help @[+ tab键] 可查看redis类型的具体操作详解 key 最大可为 512M string1234567891011# object 命令Object &lt;ENCODING|FREQ|IDLETIME|REFCOUNT&gt; &lt;key&gt;127.0.0.1:6379&gt; get str&quot;yu&quot;127.0.0.1:6379&gt; get nu&quot;2&quot;127.0.0.1:6379&gt; object encoding str&quot;embstr&quot;127.0.0.1:6379&gt; object encoding nu&quot;int&quot; bitmap 1234567891011121314151617# setbit 命令 对二进制进行操作SETBIT &lt;key&gt; offset value127.0.0.1:6379&gt; setbit str 1 1 # 0100 0000(integer) 0127.0.0.1:6379&gt; get str&quot;@&quot;127.0.0.1:6379&gt; setbit str 7 1 # 0100 0001(integer) 0127.0.0.1:6379&gt; get str&quot;A&quot;127.0.0.1:6379&gt; setbit str 7 0 (integer) 1127.0.0.1:6379&gt; setbit str 6 1 # 0100 0010(integer) 0127.0.0.1:6379&gt; get str&quot;B&quot; 123456789101112131415# bitcount 命令 对起始字节到结束字节中的二进制位为1的进行统计BITCOUNT key [start end]127.0.0.1:6379&gt; get str # 0100 0010 0100 0000&quot;B@&quot;127.0.0.1:6379&gt; bitcount str 1 1 (integer) 1127.0.0.1:6379&gt; bitcount str 0 1(integer) 3127.0.0.1:6379&gt; setbit str 14 1 # 0100 0010 0100 0010(integer) 0127.0.0.1:6379&gt; bitcount str 1 1(integer) 2127.0.0.1:6379&gt; get str&quot;BB&quot; 12345678910111213# bitpos 命令 获取“起始字节”到“结束字节”的“0”或“1”第一次出现的位置下标 BITPOS key bit [start] [end]127.0.0.1:6379&gt; get str # 0100 0010 0100 0010&quot;BB&quot;127.0.0.1:6379&gt; bitpos str 0 1 1 (integer) 8127.0.0.1:6379&gt; bitpos str 1 1 1(integer) 9127.0.0.1:6379&gt; setbit str 9 0(integer) 1127.0.0.1:6379&gt; bitpos str 1 1 1(integer) 14 123456789101112131415161718192021222324# bitop 命令 BITOP operation destkey key [key ...]operation = [and|or]127.0.0.1:6379&gt; setbit k1 1 1(integer) 0127.0.0.1:6379&gt; setbit k1 7 1(integer) 0127.0.0.1:6379&gt; get k1&quot;A&quot;127.0.0.1:6379&gt; setbit k2 1 1(integer) 0127.0.0.1:6379&gt; setbit k2 6 1(integer) 0127.0.0.1:6379&gt; get k2&quot;B&quot;127.0.0.1:6379&gt; bitop and andkey k1 k2 # 0100 0001 and 0100 0010 = 0100 0000(integer) 1127.0.0.1:6379&gt; get andkey&quot;@&quot;127.0.0.1:6379&gt; bitop or orkey k1 k2 # 0100 0001 or 0100 0010 = 0100 0011(integer) 1127.0.0.1:6379&gt; get orkey&quot;C&quot; 场景解读 &gt; incr接口调用次数 可以利用最大值 - 次数，来指定次数 incr 秒杀场景 bitmap 统计用户一段时间内的登录情况 列：bitmap 用户名 [365 1]，[25 1]即为 一年中的第25天和365天登录了 bitmap 20201019 用户名id 1，即为该用户在20201019号这一天有登录 bitmap 20201020 用户名id 1，即为该用户在20201020号这一天有登录 之后使用 bitop or 19-20 20201019 20201020来统计某时间段内的活跃用户 list123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869127.0.0.1:6379&gt; help @list BLPOP key [key ...] timeout summary: Remove and get the first element in a list, or block until one is available since: 2.0.0 BRPOP key [key ...] timeout summary: Remove and get the last element in a list, or block until one is available since: 2.0.0 BRPOPLPUSH source destination timeout summary: Pop a value from a list, push it to another list and return it; or block until one is available since: 2.2.0 LINDEX key index summary: Get an element from a list by its index since: 1.0.0 LINSERT key BEFORE|AFTER pivot value summary: Insert an element before or after another element in a list since: 2.2.0 LLEN key summary: Get the length of a list since: 1.0.0 LPOP key summary: Remove and get the first element in a list since: 1.0.0 LPUSH key value [value ...] summary: Prepend one or multiple values to a list since: 1.0.0 LPUSHX key value summary: Prepend a value to a list, only if the list exists since: 2.2.0 LRANGE key start stop summary: Get a range of elements from a list since: 1.0.0 LREM key count value summary: Remove elements from a list since: 1.0.0 LSET key index value summary: Set the value of an element in a list by its index since: 1.0.0 LTRIM key start stop summary: Trim a list to the specified range since: 1.0.0 RPOP key summary: Remove and get the last element in a list since: 1.0.0 RPOPLPUSH source destination summary: Remove the last element in a list, prepend it to another list and return it since: 1.2.0 RPUSH key value [value ...] summary: Append one or multiple values to a list since: 1.0.0 RPUSHX key value summary: Append a value to a list, only if the list exists since: 2.2.0 场景解读 &gt; 可以当：栈、队列、数组 ltrim热评论 hash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061127.0.0.1:6379&gt; help @hash HDEL key field [field ...] summary: Delete one or more hash fields since: 2.0.0 HEXISTS key field summary: Determine if a hash field exists since: 2.0.0 HGET key field summary: Get the value of a hash field since: 2.0.0 HGETALL key summary: Get all the fields and values in a hash since: 2.0.0 HINCRBY key field increment summary: Increment the integer value of a hash field by the given number since: 2.0.0 HINCRBYFLOAT key field increment summary: Increment the float value of a hash field by the given amount since: 2.6.0 HKEYS key summary: Get all the fields in a hash since: 2.0.0 HLEN key summary: Get the number of fields in a hash since: 2.0.0 HMGET key field [field ...] summary: Get the values of all the given hash fields since: 2.0.0 HMSET key field value [field value ...] summary: Set multiple hash fields to multiple values since: 2.0.0 HSCAN key cursor [MATCH pattern] [COUNT count] summary: Incrementally iterate hash fields and associated values since: 2.8.0 HSET key field value summary: Set the string value of a hash field since: 2.0.0 HSETNX key field value summary: Set the value of a hash field, only if the field does not exist since: 2.0.0 HSTRLEN key field summary: Get the length of the value of a hash field since: 3.2.0 HVALS key summary: Get all the values in a hash since: 2.0.0 场景解读 &gt; 商品详情页利用filed聚合数据 set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061127.0.0.1:6379&gt; help @set SADD key member [member ...] summary: Add one or more members to a set since: 1.0.0 SCARD key summary: Get the number of members in a set since: 1.0.0 SDIFF key [key ...] summary: Subtract multiple sets since: 1.0.0 SDIFFSTORE destination key [key ...] summary: Subtract multiple sets and store the resulting set in a key since: 1.0.0 SINTER key [key ...] summary: Intersect multiple sets since: 1.0.0 SINTERSTORE destination key [key ...] summary: Intersect multiple sets and store the resulting set in a key since: 1.0.0 SISMEMBER key member summary: Determine if a given value is a member of a set since: 1.0.0 SMEMBERS key summary: Get all the members in a set since: 1.0.0 SMOVE source destination member summary: Move a member from one set to another since: 1.0.0 SPOP key [count] summary: Remove and return one or multiple random members from a set since: 1.0.0 SRANDMEMBER key [count] # count&gt;0时，返回集合会去重，count&lt;0时，返回集合不会去重 summary: Get one or multiple random members from a set since: 1.0.0 SREM key member [member ...] summary: Remove one or more members from a set since: 1.0.0 SSCAN key cursor [MATCH pattern] [COUNT count] summary: Incrementally iterate Set elements since: 2.8.0 SUNION key [key ...] summary: Add multiple sets since: 1.0.0 SUNIONSTORE destination key [key ...] summary: Add multiple sets and store the resulting set in a key since: 1.0.0 场景解读 &gt; 抽奖 spop 随机算出一个 简单推荐系统 利用两个set集合进行并集或交集的操作；sdiff sorted_set特点： 去重、有序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293127.0.0.1:6379&gt; help @sorted_set ZADD key [NX|XX] [CH] [INCR] score member [score member ...] summary: Add one or more members to a sorted set, or update its score if it already exists since: 1.2.0 ZCARD key summary: Get the number of members in a sorted set since: 1.2.0 ZCOUNT key min max summary: Count the members in a sorted set with scores within the given values since: 2.0.0 ZINCRBY key increment member summary: Increment the score of a member in a sorted set since: 1.2.0 ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] summary: Intersect multiple sorted sets and store the resulting sorted set in a new key since: 2.0.0 ZLEXCOUNT key min max summary: Count the number of members in a sorted set between a given lexicographical range since: 2.8.9 ZPOPMAX key [count] summary: Remove and return members with the highest scores in a sorted set since: 5.0.0 ZPOPMIN key [count] summary: Remove and return members with the lowest scores in a sorted set since: 5.0.0 ZRANGE key start stop [WITHSCORES] summary: Return a range of members in a sorted set, by index since: 1.2.0 ZRANGEBYLEX key min max [LIMIT offset count] summary: Return a range of members in a sorted set, by lexicographical range since: 2.8.9 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] summary: Return a range of members in a sorted set, by score since: 1.0.5 ZRANK key member # 返回排名 summary: Determine the index of a member in a sorted set since: 2.0.0 ZREM key member [member ...] summary: Remove one or more members from a sorted set since: 1.2.0 ZREMRANGEBYLEX key min max summary: Remove all members in a sorted set between the given lexicographical range since: 2.8.9 ZREMRANGEBYRANK key start stop summary: Remove all members in a sorted set within the given indexes since: 2.0.0 ZREMRANGEBYSCORE key min max summary: Remove all members in a sorted set within the given scores since: 1.2.0 ZREVRANGE key start stop [WITHSCORES] summary: Return a range of members in a sorted set, by index, with scores ordered from high to low since: 1.2.0 ZREVRANGEBYLEX key max min [LIMIT offset count] summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings. since: 2.8.9 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] summary: Return a range of members in a sorted set, by score, with scores ordered from high to low since: 2.2.0 ZREVRANK key member summary: Determine the index of a member in a sorted set, with scores ordered from high to low since: 2.0.0 ZSCAN key cursor [MATCH pattern] [COUNT count] summary: Incrementally iterate sorted sets elements and associated scores since: 2.8.0 ZSCORE key member summary: Get the score associated with the given member in a sorted set since: 1.2.0 ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] summary: Add multiple sorted sets and store the resulting sorted set in a new key since: 2.0.0 场景解读 &gt; 排行榜 通用命令key的时效性控制 123456789101112# 为指定key设置有效期expire key secondspexpire key millisecondsexpireat key timestamppexpireat key milliseconds-timestamp# 获取key的有效时间ttl key # 返回-2 不存在，返回-1 存在，返回key的剩余时间pttl key# 切换key从时效性转为永久性persist key 数据库操作 12345678# 选择数据库 0-15select &lt;index&gt;# 数据移动move key &lt;dbindex&gt;# 查看当前库有多少个keydbsize 持久化RDB 基于快照思想，每次读写都是全部数据，大数据量下的IO性能较低。 基于fork创建子进程，内存产生额外消耗。 持久化指令 12345678910# 阻塞执行 将数据保存到rdb文件save# 生成后台线程 将数据保存到rdb文件，但不是立即执行bgsave# 配置文件自动执行save指令# save &lt;seconds&gt; &lt;changes&gt;save 900 1 # 900秒内有1个key发生改变则执行save 300 10 # 300秒内有10个key发生改变则执行save 60 10000 # 60秒内有10000个key发生改变则执行 AOF 不写全数据，每次仅追加数据 修改配置文件 1234567891011# 开启aofappendonly yes# 设置aof文件名appendfilename &quot;appendonly.aof&quot;# 设置aof保存频率 #【always】每次执行一次操作，就进行保存#【everysec】每秒执行一次保存操作#【no】# appendfsync alwaysappendfsync everysec# appendfsync no 重写aof文件 随着命令不断写入AOF，文件会越来越大，Redis引入AOF重写机制压缩文件体积。 AOF重写规则： 对同一数据的多条写命令合并为一条命令。 进程内已超时的数据不再写入文件。 忽略无效指令，重写是使用进程内数据直接成生，这样信的AOF文件只保留最终数据的写入命令，如 del key1 , hdel key2, srem key3，set name 1,set name 2等。 123456# 手动重写bgrewriteaof# 自动重写 【需继续搜索资料学习】auto-aof-rewrite-min-size &lt;size&gt;auto-aof-rewrite-percentage &lt;percentage&gt; 事务锁删除策略高级命令主从复制哨兵集群","categories":[{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/categories/redis/"},{"name":"redis使用","slug":"redis/redis使用","permalink":"http://yuxiangai.cn/categories/redis/redis%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/tags/redis/"}]},{"title":"MySQL之PXC集群","slug":"MySQL之PXC集群","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2020/10/14/MySQL之PXC集群/","link":"","permalink":"http://yuxiangai.cn/2020/10/14/MySQL%E4%B9%8BPXC%E9%9B%86%E7%BE%A4/","excerpt":"Docker环境下，部署MySQL之PXC集群的操作","text":"Docker环境下，部署MySQL之PXC集群的操作 环境 Aliyun CentOS Linux 7 Docker Version 19.03.12 Docker Image percona/percona-xtradb-cluster:5.7 实践1.下载MySQL镜像1docker pull percona/percona-xtradb-cluster:5.7 2.重命名镜像1docker tag percona/percona-xtradb-cluster:5.7 pxc:5.7 3.创建数据卷注： pxc 只支持数据卷，不支持挂载目录 12345docker volume create v1docker volume create v1docker volume create v1# 查看数据卷创建情况docker volume ls 4.创建网络，用于 pxc集群123docker network create pxc-network# 查看Docker 网络docker network ls 5.运行第一个MySQL实例节点123456docker run -di --name=pn1 \\--net=pxc-network -p 9000:3306 \\-v v1:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 pxc:5.7 查看是否创建成功 1docker logs pn1 出现下面情况测启动成功 2020-10-15T01:39:47.933208Z 0 [Note] InnoDB: Buffer pool(s) load completed at 201015 1:39:47 6.运行第二个MySQL实例节点1234567docker run -di --name=pn2 \\--net=pxc-network -p 9001:3306 \\-v v2:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn1 pxc:5.7 从第二个节点开始，就需要增加cluster_join 来指定与其进行数据同步的节点。当 PXC集群中存在两个节点以上之后就没有主节点的概念了。集群中最后一个退出的节点就会变为主节点，在/var/lib/mysql/grastate.dat 文件中属性 safe_to_bootstrap 的值 会从 0 被设置为 1 表示该节点是主节点。 7.运行第三个MySQL实例节点1234567docker run -di --name=pn3 \\--net=pxc-network -p 9002:3306 \\-v v3:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn2 pxc:5.7 这次我们指定cluster_join=pn2,可以证明当集群中有两个以上的节点时，就没有主节点的概念了。 8.进入 pn1节点123docker exec -it pn1 /bin/bash# 连接mysqlmysql -uroot -p123456 9.查看状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677mysql&gt; show status like &quot;wsrep%&quot;;+----------------------------------+-------------------------------------------------------+| Variable_name | Value |+----------------------------------+-------------------------------------------------------+| wsrep_local_state_uuid | 81380d49-0dd6-11eb-aa93-028f13d687c0 || wsrep_protocol_version | 9 || wsrep_last_applied | 25 || wsrep_last_committed | 25 || wsrep_replicated | 0 || wsrep_replicated_bytes | 0 || wsrep_repl_keys | 0 || wsrep_repl_keys_bytes | 0 || wsrep_repl_data_bytes | 0 || wsrep_repl_other_bytes | 0 || wsrep_received | 4 || wsrep_received_bytes | 656 || wsrep_local_commits | 0 || wsrep_local_cert_failures | 0 || wsrep_local_replays | 0 || wsrep_local_send_queue | 0 || wsrep_local_send_queue_max | 1 || wsrep_local_send_queue_min | 0 || wsrep_local_send_queue_avg | 0.000000 || wsrep_local_recv_queue | 0 || wsrep_local_recv_queue_max | 2 || wsrep_local_recv_queue_min | 0 || wsrep_local_recv_queue_avg | 0.250000 || wsrep_local_cached_downto | 0 || wsrep_flow_control_paused_ns | 0 || wsrep_flow_control_paused | 0.000000 || wsrep_flow_control_sent | 0 || wsrep_flow_control_recv | 0 || wsrep_flow_control_interval | [ 173, 173 ] || wsrep_flow_control_interval_low | 173 || wsrep_flow_control_interval_high | 173 || wsrep_flow_control_status | OFF || wsrep_cert_deps_distance | 0.000000 || wsrep_apply_oooe | 0.000000 || wsrep_apply_oool | 0.000000 || wsrep_apply_window | 0.000000 || wsrep_commit_oooe | 0.000000 || wsrep_commit_oool | 0.000000 || wsrep_commit_window | 0.000000 || wsrep_local_state | 4 || wsrep_local_state_comment | Synced || wsrep_cert_index_size | 0 || wsrep_cert_bucket_count | 22 || wsrep_gcache_pool_size | 1320 || wsrep_causal_reads | 0 || wsrep_cert_interval | 0.000000 || wsrep_open_transactions | 0 || wsrep_open_connections | 0 || wsrep_ist_receive_status | || wsrep_ist_receive_seqno_start | 0 || wsrep_ist_receive_seqno_current | 0 || wsrep_ist_receive_seqno_end | 0 || wsrep_incoming_addresses | a3faa8d63239:3306,254c483efa2d:3306,4745baee323f:3306 || wsrep_cluster_weight | 3 || wsrep_desync_count | 0 || wsrep_evs_delayed | || wsrep_evs_evict_list | || wsrep_evs_repl_latency | 0&#x2F;0&#x2F;0&#x2F;0&#x2F;0 || wsrep_evs_state | OPERATIONAL || wsrep_gcomm_uuid | 8b7301c0-0dd6-11eb-b180-07c4552aa3e6 || wsrep_cluster_conf_id | 3 || wsrep_cluster_size | 3 || wsrep_cluster_state_uuid | 81380d49-0dd6-11eb-aa93-028f13d687c0 || wsrep_cluster_status | Primary || wsrep_connected | ON || wsrep_local_bf_aborts | 0 || wsrep_local_index | 1 || wsrep_provider_name | Galera || wsrep_provider_vendor | Codership Oy &lt;info@codership.com&gt; || wsrep_provider_version | 3.45(ra60e019) || wsrep_ready | ON |+----------------------------------+-------------------------------------------------------+71 rows in set (0.03 sec) wsrep_incoming_addresses 属性 对应的就是三台机器的实例ID。 1| wsrep_incoming_addresses | a3faa8d63239:3306,254c483efa2d:3306,4745baee323f:3306 | 集群完整性检查： 属性 含义 wsrep_cluster_state_uuid 在集群所有节点的值应该是相同的,有不同值的节点,说明其没有连接入集群. wsrep_cluster_conf_id 正常情况下所有节点上该值是一样的.如果值不同,说明该节点被临时”分区”了.当节点之间网络连接恢复 的时候应该会恢复一样的值. wsrep_cluster_size 如果这个值跟预期的节点数一致,则所有的集群节点已经连接. wsrep_cluster_status 集群组成的状态.如果不为”Primary”,说明出现”分区”或是”split-brain”脑裂状况. 节点状态检查： 属性 含义 wsrep_ready 该值为 ON,则说明可以接受 SQL 负载.如果为 Off,则需要检查 wsrep_connected wsrep_connected 如果该值为 Off,且 wsrep_ready 的值也为 Off,则说明该节点没有连接到集群.(可能是 wsrep_cluster_address 或 wsrep_cluster_name 等配置错造成的.具体错误需要查看错误日志) wsrep_local_state_comment 如果 wsrep_connected 为 On,但 wsrep_ready 为 OFF,则可以从该项查看原因 复制健康检查: 属性 含义 wsrep_flow_control_paused 表示复制停止了多长时间.即表明集群因为 Slave 延迟而慢的程度.值为 0~1,越靠近 0 越好,值为 1 表示 复制完全停止.可优化 wsrep_slave_threads 的值来改善 wsrep_cert_deps_distance 有多少事务可以并行应用处理.wsrep_slave_threads 设置的值不应该高出该值太多 wsrep_flow_control_sent 表示该节点已经停止复制了多少次 *wsrep_local_recv_queue_avg 表示 slave 事务队列的平均长度.slave 瓶颈的预兆. 最慢的节点的 wsrep_flow_control_sent 和 wsrep_local_recv_queue_avg 这两个值最高.这两个值较低的话,相对更好 检测慢网络问题： 属性 含义 wsrep_local_send_queue_avg 网络瓶颈的预兆.如果这个值比较高的话,可能存在网络瓶颈 冲突或死锁的数目: 属性 含义 wsrep_last_committed 最后提交的事务数目 wsrep_local_cert_failures 和 wsrep_local_bf_aborts 回滚,检测到的冲突数目 集群同步验证验证集群搭建。 在节点 pn1创建数据库pxc_test 12mysql&gt; create database pxc_test; Query OK, 1 row affected (0.05 sec) 在节点pn2中查看数据库psc_test 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || pxc_test || sys || test |+--------------------+6 rows in set (0.02 sec) 在节点pn2上创建sys_user表 1234mysql&gt; use pxc_test;Database changedmysql&gt; create table sys_user ( id int primary key, name varchar(255));Query OK, 0 rows affected (0.03 sec) 在节点pn3上查看表 1234567mysql&gt; show tables;+--------------------+| Tables_in_pxc_test |+--------------------+| sys_user |+--------------------+1 row in set (0.00 sec) 在sys_user上创建数据 12345678910mysql&gt; insert into sys_user values(1,&quot;yuxiang&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.01 sec) 在pn1和pn2上查看数据 1234567mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.02 sec) 可以看到三个节点数据正常同步，并且都可读可写。 新增集群节点操作当数据库不够用时，我们通常需要增加数据库节点来分担压力，我们来演示一下新增节点的操作。 创建数据卷 1docker volume create v4 运行第四个MySQL实例容器 1234567docker run -di --name=pn4 \\--net=pxc-network -p 9003:3306 \\-v v4:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn3 pxc:5.7 这次cluster_join指定的容器是pn3。 进入pn4节点，查看数据 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || pxc_test || sys || test |+--------------------+6 rows in set (0.03 sec) 1234567mysql&gt; show tables;+--------------------+| Tables_in_pxc_test |+--------------------+| sys_user |+--------------------+1 row in set (0.00 sec) 1234567mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.01 sec) 在pn4上添加数据 1234567891011mysql&gt; insert into sys_user values(2,&quot;pxc_pn4&quot;);Query OK, 1 row affected (0.31 sec)mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang || 2 | pxc_pn4 |+----+---------+2 rows in set (0.00 sec) 在其他节点查看，数据也都同步了。 模拟宕机操作 将pn4关闭 1docker stop pn4 在pn1中插入数据 123456789101112mysql&gt; insert into sys_user values(3, &quot;down_online&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from sys_user;+----+-------------+| id | name |+----+-------------+| 1 | yuxiang || 2 | pxc_pn4 || 3 | down_online |+----+-------------+3 rows in set (0.21 sec) 重新启动pn4 1docker start pn4 查看数据 123456789mysql&gt; select * from sys_user;+----+-------------+| id | name |+----+-------------+| 1 | yuxiang || 2 | pxc_pn4 || 3 | down_online |+----+-------------+3 rows in set (0.01 sec) 数据依然同步上了 ps：当所有节点全部宕机时，需从pn1节点启动，如果pn1不是最后一个宕机的，他的volume下的grastate.dat中的safe_to_bootstrap: 0,则无法启动，需要手动将该属性值改为safe_to_bootstrap: 1","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/categories/MySQL/"},{"name":"PXC集群","slug":"MySQL/PXC集群","permalink":"http://yuxiangai.cn/categories/MySQL/PXC%E9%9B%86%E7%BE%A4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yuxiangai.cn/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/tags/MySQL/"}]},{"title":"zookeeper分布式锁","slug":"Zookeeper分布式锁","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2020/09/29/Zookeeper分布式锁/","link":"","permalink":"http://yuxiangai.cn/2020/09/29/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"Zookeeper实现分布式锁实战","text":"Zookeeper实现分布式锁实战 介绍Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 下载安装进入Zookeeper官网 下载最新版，并解压缩 启动在安装目录下 conf目录 中将zoo_sample.cfg 复制一份，命名为 zoo.cfg 12# 将**zoo.cfg**中的 dataDir属性值 修改为 &quot;安装路径&quot; + &quot;/data&quot;dataDir=D://zookeeper//apache-zookeeper-3.6.2-bin//data 启动 ./bin目录下 zkServer.cmd zkCli.cmd 命令 基本操作12345678910# create 结点 值 (创建结点和值，默认创建永久结点)create /service-user 8001# ls 结点 (查看结点下其他结点)ls /service-user# set 结点 (更改结点信息)set /service-user &#123;&quot;port&quot;:80,&quot;url&quot;:&quot;http://yuxiangai.cn&quot;&#125;# get 结点 (得到对应结点的值)get /servie-user# delete 结点 (删除结点和对应值)delete /servie-user zookeeper的结点默认是永久的，即当你断开连接后，你所创建的结点依然存在，我们可以在创建时 加入参数 -e 来指定为临时结点，当断开连接时，创建的结点会被清除 zookeeper的结点默认是唯一的，即相同名称的结点只有一个，我们可以加 -s 来给结点增加顺序，看下图 代码实现创建Maven项目 ，在Pom.xml文件中添加依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.11&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 定义接口 12345678910package com.yuxiang.adl.lock;public interface ZKLock &#123; // 加锁 void lock(); // 释放锁 void unlock();&#125; 定义抽象类 123456789101112131415161718192021222324252627282930313233343536package com.yuxiang.adl.lock;import org.I0Itec.zkclient.ZkClient;import java.util.concurrent.CountDownLatch;public abstract class ZKAbstractTemplateLock implements ZKLock&#123; protected static final String ZK_SERVER = &quot;localhost:2181&quot;; protected static final int ZK_TIMEOUT = 45 * 1000; protected ZkClient client = new ZkClient(ZK_SERVER, ZK_TIMEOUT); protected static String PATH = &quot;/service-order&quot;; protected CountDownLatch countDownLatch = null; @Override public void lock() &#123; if (tryZKLock()) &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t 占有锁成功&quot;); &#125; else &#123; waitZkLock(); lock(); &#125; &#125; @Override public void unlock() &#123; if (client != null) &#123; client.close(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t 释放锁成功&quot;); &#125; // 尝试加锁 protected abstract boolean tryZKLock(); // 加锁失败则等待 protected abstract void waitZkLock();&#125; 定义实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yuxiang.adl.lock;import org.I0Itec.zkclient.IZkDataListener;import java.util.concurrent.CountDownLatch;public class ZKDistributedLock extends ZKAbstractTemplateLock&#123; @Override protected boolean tryZKLock() &#123; try &#123; client.createEphemeral(PATH); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; @Override protected void waitZkLock() &#123; IZkDataListener iZkDataListener = new IZkDataListener() &#123; @Override public void handleDataChange(String s, Object o) throws Exception &#123; &#125; @Override public void handleDataDeleted(String s) throws Exception &#123; if (countDownLatch != null) &#123; countDownLatch.countDown(); &#125; &#125; &#125;; client.subscribeDataChanges(PATH, iZkDataListener); if (client.exists(PATH)) &#123; // 如果存在该节点，只能等着 countDownLatch = new CountDownLatch(1); try &#123; countDownLatch.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; client.unsubscribeDataChanges(PATH, iZkDataListener); &#125;&#125; 生成订单工具类 12345678package com.yuxiang.adl.util;public class OrderNumCreateUtil &#123; private static int number = 0; public String getOrderNumber() &#123; return &quot;\\t 生成订单号： &quot; + (++number); &#125;&#125; idea,5. 订单生成服务 1234567891011121314151617181920212223package com.yuxiang.adl.service;import com.yuxiang.adl.lock.ZKDistributedLock;import com.yuxiang.adl.lock.ZKLock;import com.yuxiang.adl.util.OrderNumCreateUtil;public class OrderService &#123; private OrderNumCreateUtil orderNumCreateUtil = new OrderNumCreateUtil(); private ZKLock zkLock = new ZKDistributedLock(); public void getOrderNumber() &#123; zkLock.lock(); try &#123; System.out.println(orderNumCreateUtil.getOrderNumber()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; zkLock.unlock(); &#125; &#125;&#125; Main方法 123456789101112131415package com.yuxiang.adl;import com.yuxiang.adl.service.OrderService;public class ZookeeperMain &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; new OrderService().getOrderNumber(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 类关系图","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/categories/zookeeper/"},{"name":"zookeeper分布式锁","slug":"zookeeper/zookeeper分布式锁","permalink":"http://yuxiangai.cn/categories/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/tags/zookeeper/"}]},{"title":"Gradle的下载安装与配置","slug":"Gradle的下载安装与配置","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2020/09/22/Gradle的下载安装与配置/","link":"","permalink":"http://yuxiangai.cn/2020/09/22/Gradle%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Maven的下载安装、配置及简单使用","text":"Maven的下载安装、配置及简单使用 简介Gradle是是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 面向Java应用为主。当前其支持的语言限于Java、Groovy、Kotlin和Scala，计划未来将支持更多的语言。 下载下载页面 : https://services.gradle.org/distributions 下载gradle-x.x-bin.zip(发行版) 可以自选版本，我这里选择之前的版本 gradle-5.4-bin.zip ，解压缩，放到指定目录。 配置环境变量在 此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建 变量值为Gradle的文件安装位置 修改path变量，将Gradle的bin 【%GRADLE_HOME%\\bin】添加到变量之中 在命令窗口中输出 【gradle -v】查看是否安装成功 配置本地仓库和镜像加速Gradle第一次下载文件需要到远程仓库下载，这样很慢，我们可以在本地配置一个仓库，这样第二次直接在本地加载，速度飕飕的。 还是在 此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建 在Gradle安装目录下的init.d文件中新建文件 init.gradle 输入以下内容： 1234567891011121314151617allprojects &#123; repositories &#123; maven &#123; url &#x27;file:///D:/gradlerepository&#x27;&#125; maven &#123; name &quot;Alibaba&quot; ; url &quot;https://maven.aliyun.com/repository/public&quot; &#125; mavenLocal() maven &#123; name &quot;Bstek&quot; ; url &quot;http://nexus.bsdn.org/content/groups/public/&quot; &#125; mavenCentral() &#125; buildscript &#123; repositories &#123; maven &#123; name &quot;Alibaba&quot; ; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125; maven &#123; name &quot;Bstek&quot; ; url &#x27;http://nexus.bsdn.org/content/groups/public/&#x27; &#125; maven &#123; name &quot;M2&quot; ; url &#x27;https://plugins.gradle.org/m2/&#x27; &#125; &#125; &#125;&#125; IntelliJ IDEA配置Gradle选择 file -&gt; setting 搜索 gradle 测试 创建Gradle项目 file -&gt; new -&gt; Project ,选择Gradle 填写项目名和 groupid、artifactid, version, 点击 Finish 添加 build.gradle文件中添加Spring 依赖，测试运行Spring项目 123456789101112131415group &#x27;com.yuxiang&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenLocal() mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; // https://mvnrepository.com/artifact/org.springframework/spring-context compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-context&#x27;, version: &#x27;5.2.5.RELEASE&#x27;&#125; 主类 1234567891011121314151617181920212223242526package com.yuxiang;import com.yuxiang.service.BaseService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;public class SpringMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ServiceConfig.class); BaseService baseService = (BaseService) context.getBean(&quot;baseService&quot;); Integer integer = baseService.show(10); System.out.println(integer); &#125;&#125;@ComponentScan(&quot;com.yuxiang&quot;)@Configurationclass ServiceConfig &#123;&#125; 接口 1234567package com.yuxiang.service;public interface BaseService &#123; Integer show(Integer value);&#125; 实现类 123456789101112package com.yuxiang.service.impl;import com.yuxiang.service.BaseService;import org.springframework.stereotype.Component;@Component(&quot;baseService&quot;)public class BaseServiceImpl implements BaseService &#123; @Override public Integer show(Integer value) &#123; return value * value; &#125;&#125; 运行结果","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Gradle","slug":"项目构建/Gradle","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://yuxiangai.cn/tags/Gradle/"}]},{"title":"go语言之框架Gin的简单使用","slug":"Go语言之框架Gin的简单使用","date":"un55fin55","updated":"un11fin11","comments":false,"path":"2020/07/10/Go语言之框架Gin的简单使用/","link":"","permalink":"http://yuxiangai.cn/2020/07/10/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A1%86%E6%9E%B6Gin%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"go语言之框架Gin的简单使用","text":"go语言之框架Gin的简单使用 环境 GoLang SDK 1.14 实践创建项目 在go.mod中引入gin依赖12345module &quot;go-gin-projectall&quot;go 1.14require github.com&#x2F;gin-gonic&#x2F;gin v1.6.3 简单例子123456789101112131415161718192021package mainimport &quot;github.com/gin-gonic/gin&quot;// 第一种方式func hello(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Hello &quot;, &#125;)&#125;func main() &#123; g := gin.Default() // 第二种方式 g.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Hello World&quot;, &#125;) &#125;) g.GET(&quot;/hello&quot;, hello) g.Run(&quot;:8666&quot;)&#125; 启动访问测试 Resultful风格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; g := gin.Default() g.GET(&quot;/get&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Get Request url=/get&quot;, &#125;) &#125;) g.POST(&quot;/post&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Post Request url=/post&quot;, &#125;) &#125;) g.DELETE(&quot;/delete&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Delete Request url=/delete&quot;, &#125;) &#125;) g.PUT(&quot;/put&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Put Request url=/put&quot;, &#125;) &#125;) // 匹配该路径的任何请求 g.Any(&quot;/any&quot;, func(c *gin.Context) &#123; switch c.Request.Method &#123; // 注意大写 case &quot;GET&quot;: c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;url=/any method=get&quot;&#125;) case http.MethodPost: c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;url=/any method=Post&quot;&#125;) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;Any&quot;, &#125;) &#125;) // 当没有找到匹配路径时触发 g.NoRoute(func(c *gin.Context) &#123; c.JSON(http.StatusNotFound,gin.H&#123;&quot;message&quot;: &quot;Not Found&quot;&#125;) &#125;) g.Run(&quot;:8666&quot;)&#125; 路由组123456789101112131415161718192021222324252627import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; g := gin.Default() authGroup := g.Group(&quot;/auth&quot;, func(c *gin.Context) &#123; // 当组内路径匹配时 会触发该方法 c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;url=/auth &quot;&#125;) &#125;) // 方便阅读，用一对&#123;&#125;包裹起来 &#123; // 访问路径 /auth/token authGroup.GET(&quot;/token&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Get ok&quot;&#125;) &#125;) // 访问路径 /auth/token authGroup.POST(&quot;/token&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Post ok&quot;&#125;) &#125;) &#125; g.Run(&quot;:8666&quot;)&#125; 获取上传参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;path&quot;)// UserInfo 用户信息实体type UserInfo struct &#123; Username string `form:&quot;username&quot;, json:&quot;username&quot;` Password string `form:&quot;password&quot;, json:&quot;password&quot;`&#125;func main() &#123; g := gin.Default() // 获取url中传递的参数 列：baidu.com/search?query=go语言 g.GET(&quot;/search&quot;, func(c *gin.Context) &#123; name := c.Query(&quot;query&quot;) query := c.DefaultQuery(&quot;query&quot;, &quot;当没有获取到值时，则当前为默认值&quot;) // str, isNotNull := c.GetQuery(&quot;query&quot;) // 当有值时，isNotNull=true，否则为 false c.JSON(200, gin.H&#123; &quot;keyWord&quot;: name, &quot;默认值&quot;: query, &#125;) &#125;) // 获取post方式表单提交的参数 g.POST(&quot;/login&quot;, func(c *gin.Context) &#123; user := c.PostForm(&quot;user&quot;) pwd := c.PostForm(&quot;pwd&quot;) code := c.DefaultPostForm(&quot;code&quot;, &quot;123456&quot;) c.JSON(200, gin.H&#123; &quot;post&quot;: true, &quot;user&quot;: user, &quot;pwd&quot;: pwd, &quot;code&quot;: code, &#125;) &#125;) // 获取url路径参数 g.GET(&quot;/mysql/:root/:pwd&quot;, func(c *gin.Context) &#123; root := c.Param(&quot;root&quot;) pwd := c.Param(&quot;pwd&quot;) c.JSON(200, gin.H&#123; &quot;root&quot;: root, &quot;pwd&quot;: pwd, &#125;) &#125;) // 获取数据封装为实体类 g.POST(&quot;/register&quot;, func(c *gin.Context) &#123; var u UserInfo err := c.ShouldBind(&amp;u) if err != nil &#123; fmt.Printf(&quot;bindfail %#v \\n&quot;, err) &#125; c.JSON(200, gin.H&#123; &quot;root&quot;: u.Username, &quot;pwd&quot;: u.Password, &#125;) &#125;) // 文件上传 g.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; file, _ := c.FormFile(&quot;file&quot;) //form, _ := c.MultipartForm() 上传多个文件时，使用该方法 c.JSON(200, &quot;ok&quot;) // 拼接存储路径 filePath := path.Join(&quot;./&quot;, file.Filename) // 存储 c.SaveUploadedFile(file, filePath) &#125;) g.Run(&quot;:8666&quot;)&#125; 请求转发和重定向12345678910111213141516171819202122232425func main() &#123; g := gin.Default() // 请求重定向 g.GET(&quot;/baidu&quot;, func(c *gin.Context) &#123; // 重定向 c.Redirect(http.StatusMovedPermanently, &quot;https://baidu.com&quot;) &#125;) // 请求转发 g.GET(&quot;/a&quot;, func(c *gin.Context) &#123; // 改变下一条路径 c.Request.URL.Path = &quot;/b&quot; // 注意 对象g g.HandleContext(c) &#125;) g.GET(&quot;/b&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;OK&quot;, &#125;) &#125;) g.Run(&quot;:8666&quot;)&#125; 返回HTML页面和模板解析目录结构如下 12345678910111213141516171819202122232425262728293031import ( &quot;github.com/gin-gonic/gin&quot; &quot;html/template&quot; &quot;net/http&quot;)func main() &#123; g := gin.Default() // 自定义模板解析函数 g.SetFuncMap(template.FuncMap&#123; &quot;safe&quot;: func(str string) template.HTML&#123; return template.HTML(str) &#125;, &#125;) // 扫描并加载模板 此方法要写在 SetFuncMap()方法之下，否则会出错 g.LoadHTMLGlob(&quot;./templates/**/*&quot;) g.GET(&quot;/ihtml&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;index/index.tmpl&quot;, gin.H&#123; &quot;title&quot;: &quot;&lt;a href=&#x27;www.baidu.com&#x27;&gt;百度&lt;/a&gt;&quot;, &#125;) &#125;) g.GET(&quot;/uhtml&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;user/index.tmpl&quot;, gin.H&#123; &quot;title&quot;: &quot;&lt;a href=&#x27;www.baidu.com&#x27;&gt;百度&lt;/a&gt;&quot;, &#125;) &#125;) g.Run(&quot;:8666&quot;)&#125; define &quot;name&quot; 用来定义该模板名称 123456789101112&#123;&#123; define &quot;index&#x2F;index.tmpl&quot;&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;Index Index ， &#123;&#123; .title &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#123;&#123;end&#125;&#125; 1234567891011121314&#123;&#123; define &quot;user&#x2F;index.tmpl&quot;&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &#123;&#123;&#x2F;* “.” 代表传入的对象名 “.属性名” 可以拿到传递过来value值 *&#x2F;&#125;&#125; &#123;&#123;&#x2F;* 使用自定义模板解析函数 “ | safe” *&#x2F;&#125;&#125; &lt;h1&gt;Users Index ， &#123;&#123; .title | safe&#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#123;&#123;end&#125;&#125; 加载静态文件在 &quot;index/index.tmpl&quot; 文件中引入 css文件和js文件 12&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/index.css&quot;&gt;&lt;script rel=&quot;script&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt; /resources/static/css/index.css 123h1 &#123; color: red;&#125; /resources/static/js/index.js 12var url = location.pathnamealert(url) 1234// 当静态资源访问路劲中有&#x27;参数1&#x27;的值时，则从&#x27;参数2&#x27;目录中找对应文件g.Static(&quot;/static/css&quot;, &quot;./resources/statics/css&quot;)g.Static(&quot;/static/js&quot;, &quot;./resources/statics/js&quot;)g.StaticFile(&quot;/favicon.ico&quot;, &quot;./resources/favicon.ico&quot;) 后续……","categories":[{"name":"golang","slug":"golang","permalink":"http://yuxiangai.cn/categories/golang/"},{"name":"gin","slug":"golang/gin","permalink":"http://yuxiangai.cn/categories/golang/gin/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://yuxiangai.cn/tags/Go/"},{"name":"Gin","slug":"Gin","permalink":"http://yuxiangai.cn/tags/Gin/"}]},{"title":"Maven的下载安装与配置","slug":"Maven的下载安装与配置","date":"un44fin44","updated":"un11fin11","comments":false,"path":"2020/07/09/Maven的下载安装与配置/","link":"","permalink":"http://yuxiangai.cn/2020/07/09/Maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Maven的下载安装、配置及简单使用","text":"Maven的下载安装、配置及简单使用 Maven简介Apache Maven是一个软件项目管理和理解工具。基于项目对象模型（POM）的概念，Maven可以从中央信息管理项目的构建，报告和文档。 Maven下载点击 Download进行下载 选择二进制下载，版本为3.6.3 Maven安装 解压缩之后目录 配置系统环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;新建 在path 环境变量后添加 %MAVEN_HOME%/bin 12# 查看Maven是否安装成功，使用命令mvn -version 配置本地仓库首先，我们要知道什么是仓库，详情可参考菜鸟教程 简单来说，就是“我”安装了一个软件叫Maven，当”我“输入一个jar包的名字，让Maven这个软件去帮我下载，从而不用自己再去Maven仓库手动下载。 但是，Maven默认是去中央仓库下载jar包，而中央仓库又是在国外，访问会很慢，所以配置一个本地仓库，将远程仓库的jar包下载并保存到本地，这样当下次再使用时就不用到国外去下载了，速度飕飕的。 在Maven根目录中打开conf/settings.xml，配置 localRepository，写自己创建的文件路径即可 配置阿里云镜像加速即使配置了本地仓库，第一次去国外下载依旧很慢，我们可以配置为阿里云仓库 打开Maven根目录中的conf/settings.xml文件，在 mirrors 节点上，添加内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; IntelliJ IDEA配置Maven打开IntelliJ IDEA，选择 file&gt;settings&gt;Build,Execution,Deployment&gt;Build Tools&gt;Maven 创建Maven项目新建Maven项目 file&gt;New&gt;Project 设置 GroupId、Artifactld、Version ​ GroupId: 组织名，公司网址的反写 + 项目名称 ​ ArtifactId: 项目名-模块名 ​ Version: 项目版本 选择安装位置，点击Finish完成构建 Maven目录结构1234567891011121314src -main -java java源代码文件 -resources 资源库，会自动复制到classes目录里 -webapp web应用的目录。WEB-INF、css、js等 - test -java 单元测试java源代码文件 -resources 测试需要用的资源库target - classes 项目主体输出目录 - test-classes 项目测试输出目录pom.xml maven的pom文件,再此处添加jar依赖LICENSE.txt Project’s licenseREADME.txt Project’s readme 测试在pom.xml中添加Spring依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在/src/main/java下创建Person类 123456public class Person &#123; private String name; private Integer age; // getter、setter 省略 在/src/main/resourse下创建 applicationContext.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt; &lt;constructor-arg value=&quot;yyyy-MM-dd &quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;yuxiang&quot; class=&quot;com.yuxiang.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;雨巷&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 创建程序入口类 123456789public class ApplicationMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person yuxiang = (Person) context.getBean(&quot;yuxiang&quot;); System.out.println(yuxiang); // 运行结果的 Person&#123;name=&#x27;雨巷&#x27;, age=20&#125; &#125;&#125; 项目结构图 eclipse配置Maven","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Maven","slug":"项目构建/Maven","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yuxiangai.cn/tags/Maven/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yuxiangai.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"业务功能","slug":"业务功能","permalink":"http://yuxiangai.cn/categories/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"云笔记本","slug":"阿里云/云笔记本","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/"},{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/categories/git/"},{"name":"PolarDB搭建网站","slug":"阿里云/PolarDB搭建网站","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/PolarDB%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"},{"name":"SBL负载均衡","slug":"阿里云/SBL负载均衡","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/SBL%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"Docker","slug":"阿里云/Docker","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/Docker/"},{"name":"ftp服务","slug":"阿里云/ftp服务","permalink":"http://yuxiangai.cn/categories/%E9%98%BF%E9%87%8C%E4%BA%91/ftp%E6%9C%8D%E5%8A%A1/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/categories/MySQL/"},{"name":"MySQL索引","slug":"MySQL/MySQL索引","permalink":"http://yuxiangai.cn/categories/MySQL/MySQL%E7%B4%A2%E5%BC%95/"},{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/categories/redis/"},{"name":"redis使用","slug":"redis/redis使用","permalink":"http://yuxiangai.cn/categories/redis/redis%E4%BD%BF%E7%94%A8/"},{"name":"PXC集群","slug":"MySQL/PXC集群","permalink":"http://yuxiangai.cn/categories/MySQL/PXC%E9%9B%86%E7%BE%A4/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/categories/zookeeper/"},{"name":"zookeeper分布式锁","slug":"zookeeper/zookeeper分布式锁","permalink":"http://yuxiangai.cn/categories/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"项目构建","slug":"项目构建","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Gradle","slug":"项目构建/Gradle","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Gradle/"},{"name":"golang","slug":"golang","permalink":"http://yuxiangai.cn/categories/golang/"},{"name":"gin","slug":"golang/gin","permalink":"http://yuxiangai.cn/categories/golang/gin/"},{"name":"Maven","slug":"项目构建/Maven","permalink":"http://yuxiangai.cn/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Maven/"}],"tags":[{"name":"face++","slug":"face","permalink":"http://yuxiangai.cn/tags/face/"},{"name":"ECS","slug":"ECS","permalink":"http://yuxiangai.cn/tags/ECS/"},{"name":"Leanote","slug":"Leanote","permalink":"http://yuxiangai.cn/tags/Leanote/"},{"name":"git","slug":"git","permalink":"http://yuxiangai.cn/tags/git/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yuxiangai.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"PolarDB","slug":"PolarDB","permalink":"http://yuxiangai.cn/tags/PolarDB/"},{"name":"SLB","slug":"SLB","permalink":"http://yuxiangai.cn/tags/SLB/"},{"name":"Docker","slug":"Docker","permalink":"http://yuxiangai.cn/tags/Docker/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://yuxiangai.cn/tags/vsftpd/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuxiangai.cn/tags/MySQL/"},{"name":"redis","slug":"redis","permalink":"http://yuxiangai.cn/tags/redis/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yuxiangai.cn/tags/zookeeper/"},{"name":"Gradle","slug":"Gradle","permalink":"http://yuxiangai.cn/tags/Gradle/"},{"name":"Go","slug":"Go","permalink":"http://yuxiangai.cn/tags/Go/"},{"name":"Gin","slug":"Gin","permalink":"http://yuxiangai.cn/tags/Gin/"},{"name":"Maven","slug":"Maven","permalink":"http://yuxiangai.cn/tags/Maven/"}]}