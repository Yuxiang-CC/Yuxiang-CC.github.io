{"meta":{"title":"雨巷的伞","subtitle":"","description":"Java 微服务 cloud vue 雨巷的伞","author":"yuxiang","url":"http://localhost:4000","root":"/"},"pages":[{"title":"404 Not Found","date":"un44fin44","updated":"un44fin44","comments":true,"path":"404.html","permalink":"http://localhost:4000/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"un33fin33","updated":"un33fin33","comments":false,"path":"tags/index.html","permalink":"http://localhost:4000/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"un33fin33","updated":"un33fin33","comments":false,"path":"categories/index.html","permalink":"http://localhost:4000/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"un33fin33","updated":"un33fin33","comments":false,"path":"friends/index.html","permalink":"http://localhost:4000/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"关于","date":"un33fin33","updated":"un33fin33","comments":false,"path":"about/index.html","permalink":"http://localhost:4000/about/index.html","excerpt":"","text":"关于我 雨巷的伞 大三 00后 程序员"}],"posts":[{"title":"MySQL之PXC集群","slug":"MySQL之PXC集群","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2020/10/14/MySQL之PXC集群/","link":"","permalink":"http://localhost:4000/2020/10/14/MySQL%E4%B9%8BPXC%E9%9B%86%E7%BE%A4/","excerpt":"Docker环境下，部署MySQL之PXC集群的操作","text":"Docker环境下，部署MySQL之PXC集群的操作 环境 Aliyun CentOS Linux 7 Docker Version 19.03.12 Docker Image percona/percona-xtradb-cluster:5.7 实践1.下载MySQL镜像1docker pull percona/percona-xtradb-cluster:5.7 2.重命名镜像1docker tag percona/percona-xtradb-cluster:5.7 pxc:5.7 3.创建数据卷注： pxc 只支持数据卷，不支持挂载目录 12345docker volume create v1docker volume create v1docker volume create v1# 查看数据卷创建情况docker volume ls 4.创建网络，用于 pxc集群123docker network create pxc-network# 查看Docker 网络docker network ls 5.运行第一个MySQL实例节点123456docker run -di --name=pn1 \\--net=pxc-network -p 9000:3306 \\-v v1:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 pxc:5.7 查看是否创建成功 1docker logs pn1 出现下面情况测启动成功 2020-10-15T01:39:47.933208Z 0 [Note] InnoDB: Buffer pool(s) load completed at 201015 1:39:47 6.运行第二个MySQL实例节点1234567docker run -di --name=pn2 \\--net=pxc-network -p 9001:3306 \\-v v2:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn1 pxc:5.7 从第二个节点开始，就需要增加cluster_join 来指定与其进行数据同步的节点。当 PXC集群中存在两个节点以上之后就没有主节点的概念了。集群中最后一个退出的节点就会变为主节点，在/var/lib/mysql/grastate.dat 文件中属性 safe_to_bootstrap 的值 会从 0 被设置为 1 表示该节点是主节点。 7.运行第三个MySQL实例节点1234567docker run -di --name=pn3 \\--net=pxc-network -p 9002:3306 \\-v v3:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn2 pxc:5.7 这次我们指定cluster_join=pn2,可以证明当集群中有两个以上的节点时，就没有主节点的概念了。 8.进入 pn1节点123docker exec -it pn1 /bin/bash# 连接mysqlmysql -uroot -p123456 9.查看状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677mysql&gt; show status like &quot;wsrep%&quot;;+----------------------------------+-------------------------------------------------------+| Variable_name | Value |+----------------------------------+-------------------------------------------------------+| wsrep_local_state_uuid | 81380d49-0dd6-11eb-aa93-028f13d687c0 || wsrep_protocol_version | 9 || wsrep_last_applied | 25 || wsrep_last_committed | 25 || wsrep_replicated | 0 || wsrep_replicated_bytes | 0 || wsrep_repl_keys | 0 || wsrep_repl_keys_bytes | 0 || wsrep_repl_data_bytes | 0 || wsrep_repl_other_bytes | 0 || wsrep_received | 4 || wsrep_received_bytes | 656 || wsrep_local_commits | 0 || wsrep_local_cert_failures | 0 || wsrep_local_replays | 0 || wsrep_local_send_queue | 0 || wsrep_local_send_queue_max | 1 || wsrep_local_send_queue_min | 0 || wsrep_local_send_queue_avg | 0.000000 || wsrep_local_recv_queue | 0 || wsrep_local_recv_queue_max | 2 || wsrep_local_recv_queue_min | 0 || wsrep_local_recv_queue_avg | 0.250000 || wsrep_local_cached_downto | 0 || wsrep_flow_control_paused_ns | 0 || wsrep_flow_control_paused | 0.000000 || wsrep_flow_control_sent | 0 || wsrep_flow_control_recv | 0 || wsrep_flow_control_interval | [ 173, 173 ] || wsrep_flow_control_interval_low | 173 || wsrep_flow_control_interval_high | 173 || wsrep_flow_control_status | OFF || wsrep_cert_deps_distance | 0.000000 || wsrep_apply_oooe | 0.000000 || wsrep_apply_oool | 0.000000 || wsrep_apply_window | 0.000000 || wsrep_commit_oooe | 0.000000 || wsrep_commit_oool | 0.000000 || wsrep_commit_window | 0.000000 || wsrep_local_state | 4 || wsrep_local_state_comment | Synced || wsrep_cert_index_size | 0 || wsrep_cert_bucket_count | 22 || wsrep_gcache_pool_size | 1320 || wsrep_causal_reads | 0 || wsrep_cert_interval | 0.000000 || wsrep_open_transactions | 0 || wsrep_open_connections | 0 || wsrep_ist_receive_status | || wsrep_ist_receive_seqno_start | 0 || wsrep_ist_receive_seqno_current | 0 || wsrep_ist_receive_seqno_end | 0 || wsrep_incoming_addresses | a3faa8d63239:3306,254c483efa2d:3306,4745baee323f:3306 || wsrep_cluster_weight | 3 || wsrep_desync_count | 0 || wsrep_evs_delayed | || wsrep_evs_evict_list | || wsrep_evs_repl_latency | 0&#x2F;0&#x2F;0&#x2F;0&#x2F;0 || wsrep_evs_state | OPERATIONAL || wsrep_gcomm_uuid | 8b7301c0-0dd6-11eb-b180-07c4552aa3e6 || wsrep_cluster_conf_id | 3 || wsrep_cluster_size | 3 || wsrep_cluster_state_uuid | 81380d49-0dd6-11eb-aa93-028f13d687c0 || wsrep_cluster_status | Primary || wsrep_connected | ON || wsrep_local_bf_aborts | 0 || wsrep_local_index | 1 || wsrep_provider_name | Galera || wsrep_provider_vendor | Codership Oy &lt;info@codership.com&gt; || wsrep_provider_version | 3.45(ra60e019) || wsrep_ready | ON |+----------------------------------+-------------------------------------------------------+71 rows in set (0.03 sec) wsrep_incoming_addresses 属性 对应的就是三台机器的实例ID。 1| wsrep_incoming_addresses | a3faa8d63239:3306,254c483efa2d:3306,4745baee323f:3306 | 集群完整性检查： 属性 含义 wsrep_cluster_state_uuid 在集群所有节点的值应该是相同的,有不同值的节点,说明其没有连接入集群. wsrep_cluster_conf_id 正常情况下所有节点上该值是一样的.如果值不同,说明该节点被临时”分区”了.当节点之间网络连接恢复 的时候应该会恢复一样的值. wsrep_cluster_size 如果这个值跟预期的节点数一致,则所有的集群节点已经连接. wsrep_cluster_status 集群组成的状态.如果不为”Primary”,说明出现”分区”或是”split-brain”脑裂状况. 节点状态检查： 属性 含义 wsrep_ready 该值为 ON,则说明可以接受 SQL 负载.如果为 Off,则需要检查 wsrep_connected wsrep_connected 如果该值为 Off,且 wsrep_ready 的值也为 Off,则说明该节点没有连接到集群.(可能是 wsrep_cluster_address 或 wsrep_cluster_name 等配置错造成的.具体错误需要查看错误日志) wsrep_local_state_comment 如果 wsrep_connected 为 On,但 wsrep_ready 为 OFF,则可以从该项查看原因 复制健康检查: 属性 含义 wsrep_flow_control_paused 表示复制停止了多长时间.即表明集群因为 Slave 延迟而慢的程度.值为 0~1,越靠近 0 越好,值为 1 表示 复制完全停止.可优化 wsrep_slave_threads 的值来改善 wsrep_cert_deps_distance 有多少事务可以并行应用处理.wsrep_slave_threads 设置的值不应该高出该值太多 wsrep_flow_control_sent 表示该节点已经停止复制了多少次 *wsrep_local_recv_queue_avg 表示 slave 事务队列的平均长度.slave 瓶颈的预兆. 最慢的节点的 wsrep_flow_control_sent 和 wsrep_local_recv_queue_avg 这两个值最高.这两个值较低的话,相对更好 检测慢网络问题： 属性 含义 wsrep_local_send_queue_avg 网络瓶颈的预兆.如果这个值比较高的话,可能存在网络瓶颈 冲突或死锁的数目: 属性 含义 wsrep_last_committed 最后提交的事务数目 wsrep_local_cert_failures 和 wsrep_local_bf_aborts 回滚,检测到的冲突数目 集群同步验证验证集群搭建。 在节点 pn1创建数据库pxc_test 12mysql&gt; create database pxc_test; Query OK, 1 row affected (0.05 sec) 在节点pn2中查看数据库psc_test 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || pxc_test || sys || test |+--------------------+6 rows in set (0.02 sec) 在节点pn2上创建sys_user表 1234mysql&gt; use pxc_test;Database changedmysql&gt; create table sys_user ( id int primary key, name varchar(255));Query OK, 0 rows affected (0.03 sec) 在节点pn3上查看表 1234567mysql&gt; show tables;+--------------------+| Tables_in_pxc_test |+--------------------+| sys_user |+--------------------+1 row in set (0.00 sec) 在sys_user上创建数据 12345678910mysql&gt; insert into sys_user values(1,&quot;yuxiang&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.01 sec) 在pn1和pn2上查看数据 1234567mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.02 sec) 可以看到三个节点数据正常同步，并且都可读可写。 新增集群节点操作当数据库不够用时，我们通常需要增加数据库节点来分担压力，我们来演示一下新增节点的操作。 创建数据卷 1docker volume create v4 运行第四个MySQL实例容器 1234567docker run -di --name=pn4 \\--net=pxc-network -p 9003:3306 \\-v v4:/var/lib/mysql --privileged \\-e MYSQL_ROOT_PASSWORD=123456 \\-e CLUSTER_NAME=cluster1 \\-e XTRABACKUP_PASSWORD=123456 \\-e CLUSTER_JOIN=pn3 pxc:5.7 这次cluster_join指定的容器是pn3。 进入pn4节点，查看数据 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || pxc_test || sys || test |+--------------------+6 rows in set (0.03 sec) 1234567mysql&gt; show tables;+--------------------+| Tables_in_pxc_test |+--------------------+| sys_user |+--------------------+1 row in set (0.00 sec) 1234567mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang |+----+---------+1 row in set (0.01 sec) 在pn4上添加数据 1234567891011mysql&gt; insert into sys_user values(2,&quot;pxc_pn4&quot;);Query OK, 1 row affected (0.31 sec)mysql&gt; select * from sys_user;+----+---------+| id | name |+----+---------+| 1 | yuxiang || 2 | pxc_pn4 |+----+---------+2 rows in set (0.00 sec) 在其他节点查看，数据也都同步了。 模拟宕机操作 将pn4关闭 1docker stop pn4 在pn1中插入数据 123456789101112mysql&gt; insert into sys_user values(3, &quot;down_online&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from sys_user;+----+-------------+| id | name |+----+-------------+| 1 | yuxiang || 2 | pxc_pn4 || 3 | down_online |+----+-------------+3 rows in set (0.21 sec) 重新启动pn4 1docker start pn4 查看数据 123456789mysql&gt; select * from sys_user;+----+-------------+| id | name |+----+-------------+| 1 | yuxiang || 2 | pxc_pn4 || 3 | down_online |+----+-------------+3 rows in set (0.01 sec) 数据依然同步上了 ps：当所有节点全部宕机时，需从pn1节点启动，如果pn1不是最后一个宕机的，他的volume下的grastate.dat中的safe_to_bootstrap: 0,则无法启动，需要手动将该属性值改为safe_to_bootstrap: 1","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/categories/MySQL/"},{"name":"PXC集群","slug":"MySQL/PXC集群","permalink":"http://localhost:4000/categories/MySQL/PXC%E9%9B%86%E7%BE%A4/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/tags/MySQL/"}]},{"title":"zookeeper分布式锁","slug":"zookeeper分布式锁","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2020/09/29/zookeeper分布式锁/","link":"","permalink":"http://localhost:4000/2020/09/29/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"Zookeeper实现分布式锁实战","text":"Zookeeper实现分布式锁实战 介绍Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 下载安装进入Zookeeper官网 下载最新版，并解压缩 启动在安装目录下 conf目录 中将zoo_sample.cfg 复制一份，命名为 zoo.cfg 12# 将**zoo.cfg**中的 dataDir属性值 修改为 \"安装路径\" + \"/data\"dataDir=D://zookeeper//apache-zookeeper-3.6.2-bin//data 启动 ./bin目录下 zkServer.cmd zkCli.cmd 命令 基本操作12345678910# create 结点 值 (创建结点和值，默认创建永久结点)create /service-user 8001# ls 结点 (查看结点下其他结点)ls /service-user# set 结点 (更改结点信息)set /service-user &#123;\"port\":80,\"url\":\"http://yuxiangai.cn\"&#125;# get 结点 (得到对应结点的值)get /servie-user# delete 结点 (删除结点和对应值)delete /servie-user zookeeper的结点默认是永久的，即当你断开连接后，你所创建的结点依然存在，我们可以在创建时 加入参数 -e 来指定为临时结点，当断开连接时，创建的结点会被清除 zookeeper的结点默认是唯一的，即相同名称的结点只有一个，我们可以加 -s 来给结点增加顺序，看下图 代码实现创建Maven项目 ，在Pom.xml文件中添加依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.11&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 定义接口 12345678910package com.yuxiang.adl.lock;public interface ZKLock &#123; // 加锁 void lock(); // 释放锁 void unlock();&#125; 定义抽象类 123456789101112131415161718192021222324252627282930313233343536package com.yuxiang.adl.lock;import org.I0Itec.zkclient.ZkClient;import java.util.concurrent.CountDownLatch;public abstract class ZKAbstractTemplateLock implements ZKLock&#123; protected static final String ZK_SERVER = \"localhost:2181\"; protected static final int ZK_TIMEOUT = 45 * 1000; protected ZkClient client = new ZkClient(ZK_SERVER, ZK_TIMEOUT); protected static String PATH = \"/service-order\"; protected CountDownLatch countDownLatch = null; @Override public void lock() &#123; if (tryZKLock()) &#123; System.out.println(Thread.currentThread().getName() + \"\\t 占有锁成功\"); &#125; else &#123; waitZkLock(); lock(); &#125; &#125; @Override public void unlock() &#123; if (client != null) &#123; client.close(); &#125; System.out.println(Thread.currentThread().getName() + \"\\t 释放锁成功\"); &#125; // 尝试加锁 protected abstract boolean tryZKLock(); // 加锁失败则等待 protected abstract void waitZkLock();&#125; 定义实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.yuxiang.adl.lock;import org.I0Itec.zkclient.IZkDataListener;import java.util.concurrent.CountDownLatch;public class ZKDistributedLock extends ZKAbstractTemplateLock&#123; @Override protected boolean tryZKLock() &#123; try &#123; client.createEphemeral(PATH); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; @Override protected void waitZkLock() &#123; IZkDataListener iZkDataListener = new IZkDataListener() &#123; @Override public void handleDataChange(String s, Object o) throws Exception &#123; &#125; @Override public void handleDataDeleted(String s) throws Exception &#123; if (countDownLatch != null) &#123; countDownLatch.countDown(); &#125; &#125; &#125;; client.subscribeDataChanges(PATH, iZkDataListener); if (client.exists(PATH)) &#123; // 如果存在该节点，只能等着 countDownLatch = new CountDownLatch(1); try &#123; countDownLatch.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; client.unsubscribeDataChanges(PATH, iZkDataListener); &#125;&#125; 生成订单工具类 12345678package com.yuxiang.adl.util;public class OrderNumCreateUtil &#123; private static int number = 0; public String getOrderNumber() &#123; return \"\\t 生成订单号： \" + (++number); &#125;&#125; 订单生成服务 12345678910111213141516171819202122package com.yuxiang.adl.service;import com.yuxiang.adl.lock.ZKDistributedLock;import com.yuxiang.adl.lock.ZKLock;import com.yuxiang.adl.util.OrderNumCreateUtil;public class OrderService &#123; private OrderNumCreateUtil orderNumCreateUtil = new OrderNumCreateUtil(); private ZKLock zkLock = new ZKDistributedLock(); public void getOrderNumber() &#123; zkLock.lock(); try &#123; System.out.println(orderNumCreateUtil.getOrderNumber()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; zkLock.unlock(); &#125; &#125;&#125; Main方法 123456789101112131415package com.yuxiang.adl;import com.yuxiang.adl.service.OrderService;public class ZookeeperMain &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; new OrderService().getOrderNumber(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 类关系图","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://localhost:4000/categories/zookeeper/"},{"name":"zookeeper分布式锁","slug":"zookeeper/zookeeper分布式锁","permalink":"http://localhost:4000/categories/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://localhost:4000/tags/zookeeper/"}]},{"title":"Gradle的下载安装与配置","slug":"Gradle的下载安装与配置","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2020/09/22/Gradle的下载安装与配置/","link":"","permalink":"http://localhost:4000/2020/09/22/Gradle%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Maven的下载安装、配置及简单使用","text":"Maven的下载安装、配置及简单使用 简介Gradle是是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 面向Java应用为主。当前其支持的语言限于Java、Groovy、Kotlin和Scala，计划未来将支持更多的语言。 下载下载页面 : https://services.gradle.org/distributions 下载gradle-x.x-bin.zip(发行版) 可以自选版本，我这里选择之前的版本 gradle-5.4-bin.zip ，解压缩，放到指定目录。 配置环境变量在 此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建 变量值为Gradle的文件安装位置 修改path变量，将Gradle的bin 【%GRADLE_HOME%\\bin】添加到变量之中 在命令窗口中输出 【gradle -v】查看是否安装成功 配置本地仓库和镜像加速Gradle第一次下载文件需要到远程仓库下载，这样很慢，我们可以在本地配置一个仓库，这样第二次直接在本地加载，速度飕飕的。 还是在 此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建 在Gradle安装目录下的init.d文件中新建文件 init.gradle 输入以下内容： 1234567891011121314151617allprojects &#123; repositories &#123; maven &#123; url 'file:///D:/gradlerepository'&#125; maven &#123; name \"Alibaba\" ; url \"https://maven.aliyun.com/repository/public\" &#125; mavenLocal() maven &#123; name \"Bstek\" ; url \"http://nexus.bsdn.org/content/groups/public/\" &#125; mavenCentral() &#125; buildscript &#123; repositories &#123; maven &#123; name \"Alibaba\" ; url 'https://maven.aliyun.com/repository/public' &#125; maven &#123; name \"Bstek\" ; url 'http://nexus.bsdn.org/content/groups/public/' &#125; maven &#123; name \"M2\" ; url 'https://plugins.gradle.org/m2/' &#125; &#125; &#125;&#125; IntelliJ IDEA配置Gradle选择 file -&gt; setting 搜索 gradle 测试 创建Gradle项目 file -&gt; new -&gt; Project ,选择Gradle 填写项目名和 groupid、artifactid, version, 点击 Finish 添加 build.gradle文件中添加Spring 依赖，测试运行Spring项目 123456789101112131415group 'com.yuxiang'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories &#123; mavenLocal() mavenCentral()&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.12' // https://mvnrepository.com/artifact/org.springframework/spring-context compile group: 'org.springframework', name: 'spring-context', version: '5.2.5.RELEASE'&#125; 主类 1234567891011121314151617181920212223242526package com.yuxiang;import com.yuxiang.service.BaseService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;public class SpringMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ServiceConfig.class); BaseService baseService = (BaseService) context.getBean(\"baseService\"); Integer integer = baseService.show(10); System.out.println(integer); &#125;&#125;@ComponentScan(\"com.yuxiang\")@Configurationclass ServiceConfig &#123;&#125; 接口 123456package com.yuxiang.service;public interface BaseService &#123; Integer show(Integer value);&#125; 实现类 123456789101112package com.yuxiang.service.impl;import com.yuxiang.service.BaseService;import org.springframework.stereotype.Component;@Component(\"baseService\")public class BaseServiceImpl implements BaseService &#123; @Override public Integer show(Integer value) &#123; return value * value; &#125;&#125; 运行结果","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Gradle","slug":"项目构建/Gradle","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://localhost:4000/tags/Gradle/"}]},{"title":"go语言之框架Gin的简单使用","slug":"go语言之框架Gin的简单使用","date":"un55fin55","updated":"un22fin22","comments":false,"path":"2020/07/10/go语言之框架Gin的简单使用/","link":"","permalink":"http://localhost:4000/2020/07/10/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A1%86%E6%9E%B6Gin%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"go语言之框架Gin的简单使用","text":"go语言之框架Gin的简单使用","categories":[{"name":"golang","slug":"golang","permalink":"http://localhost:4000/categories/golang/"},{"name":"gin","slug":"golang/gin","permalink":"http://localhost:4000/categories/golang/gin/"}],"tags":[{"name":"go","slug":"go","permalink":"http://localhost:4000/tags/go/"},{"name":"gin","slug":"gin","permalink":"http://localhost:4000/tags/gin/"}]},{"title":"Maven的下载安装与配置","slug":"Maven的下载安装与配置","date":"un44fin44","updated":"un22fin22","comments":false,"path":"2020/07/09/Maven的下载安装与配置/","link":"","permalink":"http://localhost:4000/2020/07/09/Maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Maven的下载安装、配置及简单使用","text":"Maven的下载安装、配置及简单使用 Maven简介Apache Maven是一个软件项目管理和理解工具。基于项目对象模型（POM）的概念，Maven可以从中央信息管理项目的构建，报告和文档。 Maven下载点击 Download进行下载 选择二进制下载，版本为3.6.3 Maven安装 解压缩之后目录 配置系统环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;新建 在path 环境变量后添加 %MAVEN_HOME%/bin 12# 查看Maven是否安装成功，使用命令mvn -version 配置本地仓库首先，我们要知道什么是仓库，详情可参考菜鸟教程 简单来说，就是“我”安装了一个软件叫Maven，当”我“输入一个jar包的名字，让Maven这个软件去帮我下载，从而不用自己再去Maven仓库手动下载。 但是，Maven默认是去中央仓库下载jar包，而中央仓库又是在国外，访问会很慢，所以配置一个本地仓库，将远程仓库的jar包下载并保存到本地，这样当下次再使用时就不用到国外去下载了，速度飕飕的。 在Maven根目录中打开conf/settings.xml，配置 localRepository，写自己创建的文件路径即可 配置阿里云镜像加速即使配置了本地仓库，第一次去国外下载依旧很慢，我们可以配置为阿里云仓库 打开Maven根目录中的conf/settings.xml文件，在 mirrors 节点上，添加内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; IntelliJ IDEA配置Maven打开IntelliJ IDEA，选择 file&gt;settings&gt;Build 创建Maven项目新建Maven项目 file&gt;New&gt;Project 设置 GroupId、Artifactld、Version ​ GroupId: 组织名，公司网址的反写 + 项目名称 ​ ArtifactId: 项目名-模块名 ​ Version: 项目版本 选择安装位置，点击Finish完成构建 Maven目录结构1234567891011121314src -main -java java源代码文件 -resources 资源库，会自动复制到classes目录里 -webapp web应用的目录。WEB-INF、css、js等 - test -java 单元测试java源代码文件 -resources 测试需要用的资源库target - classes 项目主体输出目录 - test-classes 项目测试输出目录pom.xml maven的pom文件,再此处添加jar依赖LICENSE.txt Project’s licenseREADME.txt Project’s readme 测试在pom.xml中添加Spring依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在/src/main/java下创建Person类 123456public class Person &#123; private String name; private Integer age; // getter、setter 省略 在/src/main/resourse下创建 applicationContext.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"dateFormat\" class=\"java.text.SimpleDateFormat\"&gt; &lt;constructor-arg value=\"yyyy-MM-dd \" /&gt; &lt;/bean&gt; &lt;bean id=\"yuxiang\" class=\"com.yuxiang.Person\"&gt; &lt;property name=\"name\" value=\"雨巷\" /&gt; &lt;property name=\"age\" value=\"20\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 创建程序入口类 123456789public class ApplicationMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person yuxiang = (Person) context.getBean(\"yuxiang\"); System.out.println(yuxiang); // 运行结果的 Person&#123;name='雨巷', age=20&#125; &#125;&#125; 项目结构图 eclipse配置Maven","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Maven","slug":"项目构建/Maven","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://localhost:4000/tags/Maven/"}]},{"title":"Hello World","slug":"hello-world","date":"un55fin55","updated":"un33fin33","comments":false,"path":"2020/07/03/hello-world/","link":"","permalink":"http://localhost:4000/2020/07/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/categories/MySQL/"},{"name":"PXC集群","slug":"MySQL/PXC集群","permalink":"http://localhost:4000/categories/MySQL/PXC%E9%9B%86%E7%BE%A4/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://localhost:4000/categories/zookeeper/"},{"name":"zookeeper分布式锁","slug":"zookeeper/zookeeper分布式锁","permalink":"http://localhost:4000/categories/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"项目构建","slug":"项目构建","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"Gradle","slug":"项目构建/Gradle","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Gradle/"},{"name":"golang","slug":"golang","permalink":"http://localhost:4000/categories/golang/"},{"name":"gin","slug":"golang/gin","permalink":"http://localhost:4000/categories/golang/gin/"},{"name":"Maven","slug":"项目构建/Maven","permalink":"http://localhost:4000/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/Maven/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://localhost:4000/tags/MySQL/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://localhost:4000/tags/zookeeper/"},{"name":"Gradle","slug":"Gradle","permalink":"http://localhost:4000/tags/Gradle/"},{"name":"go","slug":"go","permalink":"http://localhost:4000/tags/go/"},{"name":"gin","slug":"gin","permalink":"http://localhost:4000/tags/gin/"},{"name":"Maven","slug":"Maven","permalink":"http://localhost:4000/tags/Maven/"}]}